# generated by datamodel-codegen:
#   filename:  api-yaml

from __future__ import annotations

from enum import Enum
from typing import Any, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Im(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    phone_number: str
    sim_serial_number: str


class Call(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    phone_number: str
    sim_serial_number: str


class ConnectionParams(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im
    call: Call


class Signature(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    content: str


class Source(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    status: Union[
        Literal["OK"],
        Literal["STOPPED"],
        Literal["ERROR"],
        Literal["CREDENTIALS"],
        Literal["PERMISSIONS"],
        Literal["CONNECTING"],
    ] = Field(..., title="AccountSourceServiceStatus")


class Items(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["MOBILE"]
    connection_params: ConnectionParams
    last_fetched_at: Optional[Any] = Field(
        default=None,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_port: float
    imap_user: str
    imap_encryption: Optional[
        Union[Literal["tls"], Literal["ssl"], Literal["starttls"], Literal["default"]]
    ] = None
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ConnectionParams1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail


class Items1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["MAIL"]
    connection_params: ConnectionParams1
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail1


class Items2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["GOOGLE_OAUTH"]
    connection_params: ConnectionParams2
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_port: float
    imap_user: str
    imap_encryption: Optional[
        Union[Literal["tls"], Literal["ssl"], Literal["starttls"], Literal["default"]]
    ] = None
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ConnectionParams3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail2


class Items3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["ICLOUD"]
    connection_params: ConnectionParams3
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail3


class Items4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["OUTLOOK"]
    connection_params: ConnectionParams4
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ConnectionParams5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    calendar: str


class Items5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["GOOGLE_CALENDAR"]
    connection_params: ConnectionParams5
    sync_token: Optional[str] = None
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    phone_number: str


class ConnectionParams6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im1


class Items6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["WHATSAPP"]
    connection_params: ConnectionParams6
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Organization(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    messaging_enabled: bool
    organization_urn: str
    mailbox_urn: str


class Proxy(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    source: Literal["USER"]
    host: str
    port: float
    protocol: Optional[
        Union[Literal["http"], Literal["https"], Literal["socks5"]]
    ] = None
    username: Optional[str] = None
    password: Optional[str] = None


class Im2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str
    premium_id: Union[str, Any] = Field(..., alias="premiumId")
    premium_contract_id: Union[str, Any] = Field(..., alias="premiumContractId")
    premium_features: Optional[
        list[
            Union[Literal["recruiter"], Literal["sales_navigator"], Literal["premium"]]
        ]
    ] = Field(default=None, alias="premiumFeatures")
    organizations: list[Organization]
    proxy: Optional[Proxy] = None


class ConnectionParams7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im2


class Items7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["LINKEDIN"]
    connection_params: ConnectionParams7
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    url: str
    user: str
    user_id: str
    team: str
    team_id: str


class ConnectionParams8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im3


class Items8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["SLACK"]
    connection_params: ConnectionParams8
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im4


class Items9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["TWITTER"]
    connection_params: ConnectionParams9
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_port: float
    imap_user: str
    imap_encryption: Optional[
        Union[Literal["tls"], Literal["ssl"], Literal["starttls"], Literal["default"]]
    ] = None
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ConnectionParams10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail4


class Items10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["EXCHANGE"]
    connection_params: ConnectionParams10
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    user_id: str
    username: str


class ConnectionParams11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im5


class Items11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["TELEGRAM"]
    connection_params: ConnectionParams11
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im6


class Items12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["INSTAGRAM"]
    connection_params: ConnectionParams12
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ConnectionParams13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im6


class Items13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["MESSENGER"]
    connection_params: ConnectionParams13
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ApiV1AccountsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["AccountList"]
    items: list[
        Union[
            Items,
            Items1,
            Items2,
            Items3,
            Items4,
            Items5,
            Items6,
            Items7,
            Items8,
            Items9,
            Items10,
            Items11,
            Items12,
            Items13,
        ]
    ]
    cursor: Any


class Type(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type
    status: Literal[400]


class Type1(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ConnectionParams14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_encryption: Optional[str] = None
    imap_port: float
    imap_user: str
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ApiV1AccountsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type1
    status: Literal[401]
    connection_params: Optional[ConnectionParams14] = Field(
        default=None, alias="connectionParams"
    )


class Type2(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type2
    status: Literal[500]


class Type3(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type3
    status: Literal[503]


class ApiV1AccountsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class DisabledFeature(str, Enum):
    LINKEDIN_RECRUITER = "linkedin_recruiter"
    LINKEDIN_SALES_NAVIGATOR = "linkedin_sales_navigator"
    LINKEDIN_ORGANIZATIONS_MAILBOXES = "linkedin_organizations_mailboxes"


class Chats(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats1(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages1(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats, Chats1]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages, Messages1]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class Protocol(str, Enum):
    HTTPS = "https"
    HTTP = "http"
    SOCKS5 = "socks5"


class Proxy1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol: Optional[Protocol] = None
    port: float
    host: str
    username: Optional[str] = Field(
        default=None, description="Optional username for proxy’s authentication."
    )
    password: Optional[str] = Field(
        default=None, description="Optional password for proxy’s authentication."
    )


class ApiV1AccountsPostRequest1(BaseModel):
    """
    Authenticate using your username and password
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["LINKEDIN"]
    proxy: Optional[Proxy1] = None
    user_agent: Optional[str] = Field(
        default=None,
        description='If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser\'s console with this command : "console.log(navigator.userAgent)"',
    )
    recruiter_contract_id: Optional[str] = Field(
        default=None,
        description="The contract that should be used with Linkedin Recruiter.",
    )
    username: str = Field(
        ..., description="Should be either an email address or a phone number."
    )
    password: str


class Chats2(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats3(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages2(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages3(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit1(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats2, Chats3]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages2, Messages3]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class Proxy2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol: Optional[Protocol] = None
    port: float
    host: str
    username: Optional[str] = Field(
        default=None, description="Optional username for proxy’s authentication."
    )
    password: Optional[str] = Field(
        default=None, description="Optional password for proxy’s authentication."
    )


class ApiV1AccountsPostRequest2(BaseModel):
    """
    Authenticate using cookies
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit1] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["LINKEDIN"]
    proxy: Optional[Proxy2] = None
    user_agent: Optional[str] = Field(
        default=None,
        description='If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser\'s console with this command : "console.log(navigator.userAgent)"',
    )
    recruiter_contract_id: Optional[str] = Field(
        default=None,
        description="The contract that should be used with Linkedin Recruiter.",
    )
    access_token: str = Field(
        ...,
        description='Linkedin access token, which is to be found under the key "li_at".',
    )
    premium_token: Optional[str] = Field(
        default=None,
        description='Linkedin Recruiter/Sales Navigator authentication cookie, which is to be found under the key "li_a". It should be used if you need to be logged to an existing session. It not provided, a new session will be started.',
    )


class ApiV1AccountsPostRequest3(BaseModel):
    """
    You just need to set the provider parameter to "WHATSAPP" to begin the authentication. In response, you will receive a string which needs to be converted to a QR code and scanned to complete the authentication.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    provider: Literal["WHATSAPP"]


class Chats4(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats5(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages4(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages5(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit2(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats4, Chats5]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages4, Messages5]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class ApiV1AccountsPostRequest4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit2] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["INSTAGRAM"]
    username: str = Field(..., description="Your Instagram username.")
    password: str = Field(..., description="Your Instagram password.")
    user_agent: Optional[str] = Field(
        default=None,
        description='If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser\'s console with this command : "console.log(navigator.userAgent)"',
    )


class Chats6(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats7(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages6(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages7(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit3(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats6, Chats7]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages6, Messages7]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class ApiV1AccountsPostRequest5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit3] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["MESSENGER"]
    username: str
    password: str


class ApiV1AccountsPostRequest6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[Literal["NO_HISTORY_SYNC"]] = None
    provider: Literal["MAIL"]
    imap_user: str
    smtp_user: str
    imap_password: str
    smtp_password: str
    imap_host: str
    imap_port: float
    smtp_host: str
    smtp_port: float
    imap_encryption: str


class ApiV1AccountsPostRequest7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[Literal["NO_HISTORY_SYNC"]] = None
    provider: Literal["GOOGLE_OAUTH"]
    refresh_token: str
    access_token: str


class ApiV1AccountsPostRequest8(BaseModel):
    """
    You just need to set the provider parameter to "TELEGRAM" to begin the authentication. In response, you will receive a string which needs to be converted to a QR code and scanned to complete the authentication. `password` is needed if 2FA is enabled on the account you try to authenticate.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    provider: Literal["TELEGRAM"]
    password: Optional[str] = None


class ApiV1AccountsPostRequest9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[Literal["NO_HISTORY_SYNC"]] = None
    provider: Literal["OUTLOOK"]
    refresh_token: str
    access_token: str
    username: str
    id: str


class ApiV1AccountsPostRequest10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    provider: Literal["TWITTER"]
    username: str
    email: str
    password: str


class ApiV1AccountsPostRequest(
    RootModel[
        Union[
            Union[ApiV1AccountsPostRequest1, ApiV1AccountsPostRequest2],
            ApiV1AccountsPostRequest3,
            ApiV1AccountsPostRequest4,
            ApiV1AccountsPostRequest5,
            ApiV1AccountsPostRequest6,
            ApiV1AccountsPostRequest7,
            ApiV1AccountsPostRequest8,
            ApiV1AccountsPostRequest9,
            ApiV1AccountsPostRequest10,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        Union[ApiV1AccountsPostRequest1, ApiV1AccountsPostRequest2],
        ApiV1AccountsPostRequest3,
        ApiV1AccountsPostRequest4,
        ApiV1AccountsPostRequest5,
        ApiV1AccountsPostRequest6,
        ApiV1AccountsPostRequest7,
        ApiV1AccountsPostRequest8,
        ApiV1AccountsPostRequest9,
        ApiV1AccountsPostRequest10,
    ]


class ApiV1AccountsPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["AccountCreated"]
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )


class Type4(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type4
    status: Literal[400]


class ApiV1AccountsPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/invalid_credentials"]
    status: Literal[401]


class Type5(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1AccountsPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type5
    status: Literal[403]


class ApiV1AccountsPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/proxy_auth_error"]
    status: Literal[407]


class ApiV1AccountsPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[408]


class ApiV1AccountsPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/operation_canceled"]
    status: Literal[409]


class ApiV1AccountsPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/auth_in_progress"]
    status: Literal[425]


class Type6(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsPostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type6
    status: Literal[500]


class ApiV1AccountsPostResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class ApiV1AccountsPostResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/proxy_error"]
    status: Literal[502]


class Type7(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsPostResponse11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type7
    status: Literal[503]


class ApiV1AccountsPostResponse12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Im8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    phone_number: str
    sim_serial_number: str


class ConnectionParams15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im8
    call: Call


class ApiV1AccountsIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["MOBILE"]
    connection_params: ConnectionParams15
    last_fetched_at: Optional[Any] = Field(
        default=None,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ConnectionParams16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail4


class ApiV1AccountsIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["MAIL"]
    connection_params: ConnectionParams16
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail6


class ApiV1AccountsIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["GOOGLE_OAUTH"]
    connection_params: ConnectionParams17
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_port: float
    imap_user: str
    imap_encryption: Optional[
        Union[Literal["tls"], Literal["ssl"], Literal["starttls"], Literal["default"]]
    ] = None
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ConnectionParams18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail7


class ApiV1AccountsIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["ICLOUD"]
    connection_params: ConnectionParams18
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail8


class ApiV1AccountsIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["OUTLOOK"]
    connection_params: ConnectionParams19
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ConnectionParams20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    calendar: str


class ApiV1AccountsIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["GOOGLE_CALENDAR"]
    connection_params: ConnectionParams20
    sync_token: Optional[str] = None
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    phone_number: str


class ConnectionParams21(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im9


class ApiV1AccountsIdGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["WHATSAPP"]
    connection_params: ConnectionParams21
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Proxy3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    source: Literal["USER"]
    host: str
    port: float
    protocol: Optional[
        Union[Literal["http"], Literal["https"], Literal["socks5"]]
    ] = None
    username: Optional[str] = None
    password: Optional[str] = None


class Im10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str
    premium_id: Union[str, Any] = Field(..., alias="premiumId")
    premium_contract_id: Union[str, Any] = Field(..., alias="premiumContractId")
    premium_features: Optional[
        list[
            Union[Literal["recruiter"], Literal["sales_navigator"], Literal["premium"]]
        ]
    ] = Field(default=None, alias="premiumFeatures")
    organizations: list[Organization]
    proxy: Optional[Proxy3] = None


class ConnectionParams22(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im10


class ApiV1AccountsIdGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["LINKEDIN"]
    connection_params: ConnectionParams22
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    url: str
    user: str
    user_id: str
    team: str
    team_id: str


class ConnectionParams23(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im11


class ApiV1AccountsIdGetResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["SLACK"]
    connection_params: ConnectionParams23
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams24(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im12


class ApiV1AccountsIdGetResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["TWITTER"]
    connection_params: ConnectionParams24
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Mail9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_port: float
    imap_user: str
    imap_encryption: Optional[
        Union[Literal["tls"], Literal["ssl"], Literal["starttls"], Literal["default"]]
    ] = None
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ConnectionParams25(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mail: Mail9


class ApiV1AccountsIdGetResponse11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["EXCHANGE"]
    connection_params: ConnectionParams25
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    user_id: str
    username: str


class ConnectionParams26(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im13


class ApiV1AccountsIdGetResponse12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["TELEGRAM"]
    connection_params: ConnectionParams26
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class Im14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    username: str


class ConnectionParams27(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im14


class ApiV1AccountsIdGetResponse13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["INSTAGRAM"]
    connection_params: ConnectionParams27
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ConnectionParams28(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    im: Im14


class ApiV1AccountsIdGetResponse14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Account"]
    type: Literal["MESSENGER"]
    connection_params: ConnectionParams28
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    created_at: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    current_signature: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    signatures: Optional[list[Signature]] = None
    groups: list[str] = Field(..., min_length=1)
    sources: list[Source]


class ApiV1AccountsIdGetResponse(
    RootModel[
        Union[
            ApiV1AccountsIdGetResponse1,
            ApiV1AccountsIdGetResponse2,
            ApiV1AccountsIdGetResponse3,
            ApiV1AccountsIdGetResponse4,
            ApiV1AccountsIdGetResponse5,
            ApiV1AccountsIdGetResponse6,
            ApiV1AccountsIdGetResponse7,
            ApiV1AccountsIdGetResponse8,
            ApiV1AccountsIdGetResponse9,
            ApiV1AccountsIdGetResponse10,
            ApiV1AccountsIdGetResponse11,
            ApiV1AccountsIdGetResponse12,
            ApiV1AccountsIdGetResponse13,
            ApiV1AccountsIdGetResponse14,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        ApiV1AccountsIdGetResponse1,
        ApiV1AccountsIdGetResponse2,
        ApiV1AccountsIdGetResponse3,
        ApiV1AccountsIdGetResponse4,
        ApiV1AccountsIdGetResponse5,
        ApiV1AccountsIdGetResponse6,
        ApiV1AccountsIdGetResponse7,
        ApiV1AccountsIdGetResponse8,
        ApiV1AccountsIdGetResponse9,
        ApiV1AccountsIdGetResponse10,
        ApiV1AccountsIdGetResponse11,
        ApiV1AccountsIdGetResponse12,
        ApiV1AccountsIdGetResponse13,
        ApiV1AccountsIdGetResponse14,
    ]


class Type8(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsIdGetResponse15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type8
    status: Literal[400]


class Type9(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ConnectionParams29(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_encryption: Optional[str] = None
    imap_port: float
    imap_user: str
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ApiV1AccountsIdGetResponse16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type9
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type10(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1AccountsIdGetResponse17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type10
    status: Literal[404]


class Type11(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsIdGetResponse18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type11
    status: Literal[500]


class Type12(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsIdGetResponse19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type12
    status: Literal[503]


class ApiV1AccountsIdGetResponse20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Chats8(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats9(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages8(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages9(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit4(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats8, Chats9]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages8, Messages9]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class Proxy4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol: Optional[Protocol] = None
    port: float
    host: str
    username: Optional[str] = Field(
        default=None, description="Optional username for proxy’s authentication."
    )
    password: Optional[str] = Field(
        default=None, description="Optional password for proxy’s authentication."
    )


class ApiV1AccountsIdPostRequest1(BaseModel):
    """
    Authenticate using your username and password
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit4] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["LINKEDIN"]
    proxy: Optional[Proxy4] = None
    user_agent: Optional[str] = Field(
        default=None,
        description='If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser\'s console with this command : "console.log(navigator.userAgent)"',
    )
    recruiter_contract_id: Optional[str] = Field(
        default=None,
        description="The contract that should be used with Linkedin Recruiter.",
    )
    username: str = Field(
        ..., description="Should be either an email address or a phone number."
    )
    password: str


class Chats10(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats11(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages10(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages11(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit5(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats10, Chats11]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages10, Messages11]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class Proxy5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol: Optional[Protocol] = None
    port: float
    host: str
    username: Optional[str] = Field(
        default=None, description="Optional username for proxy’s authentication."
    )
    password: Optional[str] = Field(
        default=None, description="Optional password for proxy’s authentication."
    )


class ApiV1AccountsIdPostRequest2(BaseModel):
    """
    Authenticate using cookies
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit5] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["LINKEDIN"]
    proxy: Optional[Proxy5] = None
    user_agent: Optional[str] = Field(
        default=None,
        description='If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser\'s console with this command : "console.log(navigator.userAgent)"',
    )
    recruiter_contract_id: Optional[str] = Field(
        default=None,
        description="The contract that should be used with Linkedin Recruiter.",
    )
    access_token: str = Field(
        ...,
        description='Linkedin access token, which is to be found under the key "li_at".',
    )
    premium_token: Optional[str] = Field(
        default=None,
        description='Linkedin Recruiter/Sales Navigator authentication cookie, which is to be found under the key "li_a". It should be used if you need to be logged to an existing session. It not provided, a new session will be started.',
    )


class ApiV1AccountsIdPostRequest3(BaseModel):
    """
    You just need to set the provider parameter to "WHATSAPP" to begin the authentication. In response, you will receive a string which needs to be converted to a QR code and scanned to complete the authentication.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    provider: Literal["WHATSAPP"]


class Chats12(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats13(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages12(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages13(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit6(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats12, Chats13]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages12, Messages13]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class ApiV1AccountsIdPostRequest4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit6] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["INSTAGRAM"]
    username: str = Field(..., description="Your Instagram username.")
    password: str = Field(..., description="Your Instagram password.")
    user_agent: Optional[str] = Field(
        default=None,
        description='If encountering disconnection issues, enter the exact user agent of the browser on which the account has been connected. You can easily retrieve it in the browser\'s console with this command : "console.log(navigator.userAgent)"',
    )


class Chats14(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats15(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages14(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages15(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class SyncLimit7(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats14, Chats15]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages14, Messages15]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class ApiV1AccountsIdPostRequest5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[SyncLimit7] = Field(
        default=None,
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )
    provider: Literal["MESSENGER"]
    username: str
    password: str


class ApiV1AccountsIdPostRequest6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[Literal["NO_HISTORY_SYNC"]] = None
    provider: Literal["MAIL"]
    imap_user: str
    smtp_user: str
    imap_password: str
    smtp_password: str
    imap_host: str
    imap_port: float
    smtp_host: str
    smtp_port: float
    imap_encryption: str


class ApiV1AccountsIdPostRequest7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[Literal["NO_HISTORY_SYNC"]] = None
    provider: Literal["GOOGLE_OAUTH"]
    refresh_token: str
    access_token: str


class ApiV1AccountsIdPostRequest8(BaseModel):
    """
    You just need to set the provider parameter to "TELEGRAM" to begin the authentication. In response, you will receive a string which needs to be converted to a QR code and scanned to complete the authentication. `password` is needed if 2FA is enabled on the account you try to authenticate.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    provider: Literal["TELEGRAM"]
    password: Optional[str] = None


class ApiV1AccountsIdPostRequest9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    sync_limit: Optional[Literal["NO_HISTORY_SYNC"]] = None
    provider: Literal["OUTLOOK"]
    refresh_token: str
    access_token: str
    username: str
    id: str


class ApiV1AccountsIdPostRequest10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: Optional[str] = Field(
        default=None,
        description="An ISO 3166-1 A-2 country code to be set as proxy's location.",
        max_length=2,
        min_length=2,
    )
    ip: Optional[Any] = Field(
        default=None, description="An IPv4 address to infer proxy's location."
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled for this account.",
    )
    provider: Literal["TWITTER"]
    username: str
    email: str
    password: str


class ApiV1AccountsIdPostRequest(
    RootModel[
        Union[
            Union[ApiV1AccountsIdPostRequest1, ApiV1AccountsIdPostRequest2],
            ApiV1AccountsIdPostRequest3,
            ApiV1AccountsIdPostRequest4,
            ApiV1AccountsIdPostRequest5,
            ApiV1AccountsIdPostRequest6,
            ApiV1AccountsIdPostRequest7,
            ApiV1AccountsIdPostRequest8,
            ApiV1AccountsIdPostRequest9,
            ApiV1AccountsIdPostRequest10,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        Union[ApiV1AccountsIdPostRequest1, ApiV1AccountsIdPostRequest2],
        ApiV1AccountsIdPostRequest3,
        ApiV1AccountsIdPostRequest4,
        ApiV1AccountsIdPostRequest5,
        ApiV1AccountsIdPostRequest6,
        ApiV1AccountsIdPostRequest7,
        ApiV1AccountsIdPostRequest8,
        ApiV1AccountsIdPostRequest9,
        ApiV1AccountsIdPostRequest10,
    ]


class ApiV1AccountsIdPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["AccountReconnected"]
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )


class Type13(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsIdPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type13
    status: Literal[400]


class ApiV1AccountsIdPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/invalid_credentials"]
    status: Literal[401]


class Type14(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1AccountsIdPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type14
    status: Literal[403]


class Type15(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1AccountsIdPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type15
    status: Literal[404]


class ApiV1AccountsIdPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/proxy_auth_error"]
    status: Literal[407]


class ApiV1AccountsIdPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[408]


class ApiV1AccountsIdPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/operation_canceled"]
    status: Literal[409]


class ApiV1AccountsIdPostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/auth_in_progress"]
    status: Literal[425]


class Type16(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsIdPostResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type16
    status: Literal[500]


class ApiV1AccountsIdPostResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/proxy_error"]
    status: Literal[502]


class Type17(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsIdPostResponse11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type17
    status: Literal[503]


class ApiV1AccountsIdPostResponse12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1AccountsIdDeleteResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["AccountDeleted"]


class Type18(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsIdDeleteResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type18
    status: Literal[400]


class Type19(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1AccountsIdDeleteResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type19
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type20(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1AccountsIdDeleteResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type20
    status: Literal[404]


class Type21(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsIdDeleteResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type21
    status: Literal[500]


class Type22(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsIdDeleteResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type22
    status: Literal[503]


class ApiV1AccountsIdDeleteResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class LinkedinProduct(str, Enum):
    CLASSIC = "classic"
    RECRUITER = "recruiter"
    SALES_NAVIGATOR = "sales_navigator"


class Status(str, Enum):
    """
    The status of the synchronization. You can setup a regular polling on the same route to get updates on its status. A new request after a SYNC_DONE or SYNC_ERROR response will start a fresh sync.
    """

    SYNC_STARTED = "SYNC_STARTED"
    SYNC_RUNNING = "SYNC_RUNNING"
    SYNC_DONE = "SYNC_DONE"
    SYNC_ERROR = "SYNC_ERROR"


class ApiV1AccountsAccountIdSyncGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["AccountResync"]
    status: Status = Field(
        ...,
        description="The status of the synchronization. You can setup a regular polling on the same route to get updates on its status. A new request after a SYNC_DONE or SYNC_ERROR response will start a fresh sync.",
    )


class Type23(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsAccountIdSyncGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type23
    status: Literal[400]


class Type24(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1AccountsAccountIdSyncGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type24
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type25(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1AccountsAccountIdSyncGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type25
    status: Literal[403]


class Type26(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1AccountsAccountIdSyncGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type26
    status: Literal[404]


class Type27(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsAccountIdSyncGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type27
    status: Literal[500]


class ApiV1AccountsAccountIdSyncGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type28(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsAccountIdSyncGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type28
    status: Literal[503]


class ApiV1AccountsAccountIdSyncGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Provider(str, Enum):
    LINKEDIN = "LINKEDIN"
    INSTAGRAM = "INSTAGRAM"
    TWITTER = "TWITTER"
    MESSENGER = "MESSENGER"


class ApiV1AccountsCheckpointPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    code: str = Field(
        ...,
        description="The code to solve the checkpoint. If the code is a phone number, it should be preceded by the international dialling code in brackets (e.g. (+33)0612345678 for France).",
        min_length=1,
    )
    provider: Provider


class ApiV1AccountsCheckpointPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["AccountCreated"]
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )


class Type29(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsCheckpointPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type29
    status: Literal[400]


class ApiV1AccountsCheckpointPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/invalid_checkpoint_solution"]
    status: Literal[401]


class Type30(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1AccountsCheckpointPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type30
    status: Literal[403]


class ApiV1AccountsCheckpointPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/proxy_auth_error"]
    status: Literal[407]


class ApiV1AccountsCheckpointPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[408]


class ApiV1AccountsCheckpointPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/operation_canceled"]
    status: Literal[409]


class Type31(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsCheckpointPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type31
    status: Literal[500]


class ApiV1AccountsCheckpointPostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/proxy_error"]
    status: Literal[502]


class Type32(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsCheckpointPostResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type32
    status: Literal[503]


class ApiV1AccountsCheckpointPostResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Provider1(str, Enum):
    LINKEDIN = "LINKEDIN"
    INSTAGRAM = "INSTAGRAM"


class ApiV1AccountsCheckpointResendPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    provider: Provider1


class ApiV1AccountsCheckpointResendPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["CheckpointResend"]
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    success: bool


class Type33(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsCheckpointResendPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type33
    status: Literal[400]


class Type34(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1AccountsCheckpointResendPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type34
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type35(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsCheckpointResendPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type35
    status: Literal[500]


class ApiV1AccountsCheckpointResendPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type36(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsCheckpointResendPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type36
    status: Literal[503]


class ApiV1AccountsCheckpointResendPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Object(str, Enum):
    ACCOUNT_RESTARTED = "AccountRestarted"
    ACCOUNT_FAILED_TO_RESTART = "AccountFailedToRestart"


class ApiV1AccountsIdRestartPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Object


class Type37(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1AccountsIdRestartPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type37
    status: Literal[400]


class Type38(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1AccountsIdRestartPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type38
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type39(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1AccountsIdRestartPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type39
    status: Literal[404]


class Type40(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1AccountsIdRestartPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type40
    status: Literal[500]


class Type41(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1AccountsIdRestartPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type41
    status: Literal[503]


class ApiV1AccountsIdRestartPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class DisabledOption(str, Enum):
    PROXY = "proxy"
    AUTOPROXY = "autoproxy"
    COOKIE_AUTH = "cookie_auth"
    CREDENTIALS_AUTH = "credentials_auth"
    SYNC_LIMIT = "sync_limit"


class Proxy6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol: Optional[Protocol] = None
    port: float
    host: str
    username: Optional[str] = Field(
        default=None, description="Optional username for proxy’s authentication."
    )
    password: Optional[str] = Field(
        default=None, description="Optional password for proxy’s authentication."
    )


class Chats16(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats17(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages16(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages17(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messaging(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats16, Chats17]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages16, Messages17]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class SyncLimit8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mailing: Optional[Literal["NO_HISTORY_SYNC"]] = Field(default=None, alias="MAILING")
    messaging: Optional[Messaging] = Field(
        default=None,
        alias="MESSAGING",
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )


class Provider2(str, Enum):
    LINKEDIN = "LINKEDIN"
    WHATSAPP = "WHATSAPP"
    INSTAGRAM = "INSTAGRAM"
    MESSENGER = "MESSENGER"
    IMAP = "IMAP"
    TELEGRAM = "TELEGRAM"
    GOOGLE = "GOOGLE"
    OUTLOOK = "OUTLOOK"
    TWITTER = "TWITTER"
    MAIL = "MAIL"


class ApiV1HostedAccountsLinkPostRequest1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    expires_on: Any = Field(
        ...,
        alias="expiresOn",
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    name: Optional[str] = Field(
        default=None,
        description="This field will be sent back to you in the notify_url to help match the added account with your user.",
        min_length=1,
    )
    success_redirect_url: Optional[Any] = Field(
        default=None,
        description="A url where you might want to redirect the user in case of a successful authentication.",
    )
    failure_redirect_url: Optional[Any] = Field(
        default=None,
        description="A url where you might want to redirect the user in case of a failed authentication.",
    )
    bypass_success_screen: Optional[bool] = Field(
        default=None,
        description="Whether to bypass the hosted auth success screen before accessing the success_redirect_url.",
    )
    notify_url: Optional[Any] = Field(
        default=None,
        description="A url where you can be notified about events related to the authentication process.",
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled in this account. Accepted values : linkedin_recruiter | linkedin_sales_navigator | linkedin_organizations_mailboxes.",
    )
    disabled_options: Optional[list[DisabledOption]] = Field(
        default=None,
        description="An array of options that should be disabled in hosted auth interface. Accepted values : proxy | cookie_auth | credentials_auth | sync_limit.",
    )
    proxy: Optional[Proxy6] = None
    api_url: Any = Field(
        ...,
        description="The url of your Unipile server  : https://{subdomain}.unipile.com:{port}",
    )
    sync_limit: Optional[SyncLimit8] = None
    type: Literal["create"] = Field(
        ...,
        description="A litteral value to choose between a connection or a reconnection.",
    )
    providers: Union[
        Literal["*"], Literal["*:MAILING"], Literal["*:MESSAGING"], list[Provider2]
    ] = Field(
        ...,
        description="The providers for whom you want to propose to connect an account.",
    )


class Proxy7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    protocol: Optional[Protocol] = None
    port: float
    host: str
    username: Optional[str] = Field(
        default=None, description="Optional username for proxy’s authentication."
    )
    password: Optional[str] = Field(
        default=None, description="Optional password for proxy’s authentication."
    )


class Chats18(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Chats19(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messages18(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Messages19(RootModel[float]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: float = Field(
        ...,
        description="The quantity of data that should be synced from data history. 0 will not sync history.",
        ge=0.0,
    )


class Messaging1(BaseModel):
    """
    Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    chats: Optional[Union[Chats18, Chats19]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )
    messages: Optional[Union[Messages18, Messages19]] = Field(
        default=None,
        description="Either a UTC Datetime to start sync from, or a quantity of data.",
    )


class SyncLimit9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    mailing: Optional[Literal["NO_HISTORY_SYNC"]] = Field(default=None, alias="MAILING")
    messaging: Optional[Messaging1] = Field(
        default=None,
        alias="MESSAGING",
        description="Set a sync limit either for chats, messages or both. Chats limit will apply to each inbox, whereas messages limit will apply to each chat. No value will not apply any limit (default behaviour). Providers partial support.",
    )


class ApiV1HostedAccountsLinkPostRequest2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    expires_on: Any = Field(
        ...,
        alias="expiresOn",
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    name: Optional[str] = Field(
        default=None,
        description="This field will be sent back to you in the notify_url to help match the added account with your user.",
        min_length=1,
    )
    success_redirect_url: Optional[Any] = Field(
        default=None,
        description="A url where you might want to redirect the user in case of a successful authentication.",
    )
    failure_redirect_url: Optional[Any] = Field(
        default=None,
        description="A url where you might want to redirect the user in case of a failed authentication.",
    )
    bypass_success_screen: Optional[bool] = Field(
        default=None,
        description="Whether to bypass the hosted auth success screen before accessing the success_redirect_url.",
    )
    notify_url: Optional[Any] = Field(
        default=None,
        description="A url where you can be notified about events related to the authentication process.",
    )
    disabled_features: Optional[list[DisabledFeature]] = Field(
        default=None,
        description="An array of features that should be disabled in this account. Accepted values : linkedin_recruiter | linkedin_sales_navigator | linkedin_organizations_mailboxes.",
    )
    disabled_options: Optional[list[DisabledOption]] = Field(
        default=None,
        description="An array of options that should be disabled in hosted auth interface. Accepted values : proxy | cookie_auth | credentials_auth | sync_limit.",
    )
    proxy: Optional[Proxy7] = None
    api_url: Any = Field(
        ...,
        description="The url of your Unipile server  : https://{subdomain}.unipile.com:{port}",
    )
    sync_limit: Optional[SyncLimit9] = None
    type: Literal["reconnect"] = Field(
        ...,
        description="A litteral value to choose between a connection or a reconnection.",
    )
    reconnect_account: str = Field(
        ..., description="The id of the account to reconnect.", min_length=1
    )


class ApiV1HostedAccountsLinkPostRequest(
    RootModel[
        Union[ApiV1HostedAccountsLinkPostRequest1, ApiV1HostedAccountsLinkPostRequest2]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        ApiV1HostedAccountsLinkPostRequest1, ApiV1HostedAccountsLinkPostRequest2
    ]


class ApiV1HostedAccountsLinkPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["HostedAuthUrl"]
    url: str = Field(
        ...,
        description="A url redirecting to Unipile's hosted authentication for account connection or reconnection.",
    )


class Type42(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1HostedAccountsLinkPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type42
    status: Literal[400]


class Type43(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1HostedAccountsLinkPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type43
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type44(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1HostedAccountsLinkPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type44
    status: Literal[500]


class Type45(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1HostedAccountsLinkPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type45
    status: Literal[503]


class ApiV1HostedAccountsLinkPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ReadDate(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Items14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Email"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    kind: Literal["0_ref"]
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str


class IdentifierType(str, Enum):
    CHAT_ATTENDEE_ID = "CHAT_ATTENDEE_ID"
    PHONE_NUMBER = "PHONE_NUMBER"
    EMAIL_ADDRESS = "EMAIL_ADDRESS"
    MESSENGER_ID = "MESSENGER_ID"
    MESSENGER_THREAD_ID = "MESSENGER_THREAD_ID"
    TIKTOK_ID = "TIKTOK_ID"
    TIKTOK_THREAD_ID = "TIKTOK_THREAD_ID"
    TWITTER_ID = "TWITTER_ID"
    TWITTER_THREAD_ID = "TWITTER_THREAD_ID"
    INSTAGRAM_ID = "INSTAGRAM_ID"
    INSTAGRAM_THREAD_ID = "INSTAGRAM_THREAD_ID"
    LINKEDIN_ID = "LINKEDIN_ID"
    LINKEDIN_THREAD_ID = "LINKEDIN_THREAD_ID"
    GROUP_THREAD = "GROUP_THREAD"


class FromAttendee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ToAttendee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class CcAttendee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class BccAttendee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ReplyToAttendee(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class InReplyTo(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    message_id: str
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )


class Attachment(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    name: str
    size: float
    extension: str
    mime: str
    cid: Optional[str] = None


class FromAttendee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ToAttendee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class CcAttendee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class BccAttendee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ReplyToAttendee1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ParentMail(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str
    kind: Literal["1_meta"]
    body_plain: Literal[""]
    body: Literal[""]
    from_attendee: FromAttendee1
    to_attendees: Optional[list[ToAttendee1]] = None
    cc_attendees: Optional[list[CcAttendee1]] = None
    bcc_attendees: Optional[list[BccAttendee1]] = None
    reply_to_attendees: Optional[list[ReplyToAttendee1]] = None
    subject: str
    has_attachments: bool
    origin: Union[Literal["unipile"], Literal["external"]]
    in_reply_to: Optional[InReplyTo] = None
    tracking_id: Optional[str] = None
    thread_id: Optional[str] = None
    attachments: list[Attachment]


class Items15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Email"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str
    kind: Literal["1_meta"]
    body_plain: Literal[""]
    body: Literal[""]
    from_attendee: FromAttendee
    to_attendees: Optional[list[ToAttendee]] = None
    cc_attendees: Optional[list[CcAttendee]] = None
    bcc_attendees: Optional[list[BccAttendee]] = None
    reply_to_attendees: Optional[list[ReplyToAttendee]] = None
    subject: str
    has_attachments: bool
    origin: Union[Literal["unipile"], Literal["external"]]
    in_reply_to: Optional[InReplyTo] = None
    tracking_id: Optional[str] = None
    thread_id: Optional[str] = None
    attachments: list[Attachment]
    parent_mail: Optional[ParentMail] = None


class FromAttendee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ToAttendee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class CcAttendee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class BccAttendee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ReplyToAttendee2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class Header(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    value: str


class Items16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Email"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str
    from_attendee: FromAttendee2
    to_attendees: Optional[list[ToAttendee2]] = None
    cc_attendees: Optional[list[CcAttendee2]] = None
    bcc_attendees: Optional[list[BccAttendee2]] = None
    reply_to_attendees: Optional[list[ReplyToAttendee2]] = None
    subject: str
    has_attachments: bool
    origin: Union[Literal["unipile"], Literal["external"]]
    in_reply_to: Optional[InReplyTo] = None
    tracking_id: Optional[str] = None
    thread_id: Optional[str] = None
    attachments: list[Attachment]
    kind: Literal["2_full"]
    body_plain: str
    body: str
    headers: Optional[list[Header]] = None


class ApiV1EmailsGetResponse(BaseModel):
    """
    @todo List of Emails.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["EmailList"]
    items: list[Union[Items14, Items15, Items16]]
    cursor: Any


class Type46(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1EmailsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type46
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type47(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1EmailsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type47
    status: Literal[403]


class Type48(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1EmailsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type48
    status: Literal[500]


class Type49(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1EmailsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type49
    status: Literal[503]


class ApiV1EmailsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class From(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = Field(
        default=None, description="The name of the attendee."
    )
    identifier: Optional[str] = Field(
        default=None, description="The email address of the attendee."
    )


class ToItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = Field(
        default=None, description="The name of the attendee."
    )
    identifier: str = Field(..., description="The email address of the attendee.")


class CcItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = Field(
        default=None, description="The name of the attendee."
    )
    identifier: str = Field(..., description="The email address of the attendee.")


class BccItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = Field(
        default=None, description="The name of the attendee."
    )
    identifier: str = Field(..., description="The email address of the attendee.")


class CustomHeader(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(..., description="The header name. Must start with 'X-' or 'x-'.")
    value: str


class TrackingOptions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    opens: Optional[bool] = None
    links: Optional[bool] = None
    label: Optional[str] = None
    custom_domain: Optional[str] = None


class ApiV1EmailsPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    from_: Optional[From] = Field(default=None, alias="from")
    to: list[ToItem]
    cc: Optional[list[CcItem]] = None
    bcc: Optional[list[BccItem]] = None
    subject: Optional[str] = None
    body: str
    reply_to: Optional[str] = Field(
        default=None,
        description="Either the Unipile ID or the provider ID of the email to reply to.",
    )
    custom_headers: Optional[list[CustomHeader]] = Field(
        default=None, description="An array of custom headers to be added to the email."
    )
    tracking_options: Optional[TrackingOptions] = None
    attachments: Optional[list[bytes]] = None


class ApiV1EmailsPostResponse(BaseModel):
    """
    @todo Email has been sent.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["EmailSent"]
    tracking_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )


class Type50(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1EmailsPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type50
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type51(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1EmailsPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type51
    status: Literal[403]


class Type52(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1EmailsPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type52
    status: Literal[404]


class Type53(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1EmailsPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type53
    status: Literal[422]


class Type54(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1EmailsPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type54
    status: Literal[500]


class Type55(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1EmailsPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type55
    status: Literal[503]


class ApiV1EmailsPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1EmailsEmailIdGetResponse1(BaseModel):
    """
    @todo Email
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Email"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    kind: Literal["0_ref"]
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str


class FromAttendee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ToAttendee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class CcAttendee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class BccAttendee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ReplyToAttendee3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class FromAttendee4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ToAttendee4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class CcAttendee4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class BccAttendee4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ReplyToAttendee4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ParentMail1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str
    kind: Literal["1_meta"]
    body_plain: Literal[""]
    body: Literal[""]
    from_attendee: FromAttendee4
    to_attendees: Optional[list[ToAttendee4]] = None
    cc_attendees: Optional[list[CcAttendee4]] = None
    bcc_attendees: Optional[list[BccAttendee4]] = None
    reply_to_attendees: Optional[list[ReplyToAttendee4]] = None
    subject: str
    has_attachments: bool
    origin: Union[Literal["unipile"], Literal["external"]]
    in_reply_to: Optional[InReplyTo] = None
    tracking_id: Optional[str] = None
    thread_id: Optional[str] = None
    attachments: list[Attachment]


class ApiV1EmailsEmailIdGetResponse2(BaseModel):
    """
    @todo Email
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Email"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str
    kind: Literal["1_meta"]
    body_plain: Literal[""]
    body: Literal[""]
    from_attendee: FromAttendee3
    to_attendees: Optional[list[ToAttendee3]] = None
    cc_attendees: Optional[list[CcAttendee3]] = None
    bcc_attendees: Optional[list[BccAttendee3]] = None
    reply_to_attendees: Optional[list[ReplyToAttendee3]] = None
    subject: str
    has_attachments: bool
    origin: Union[Literal["unipile"], Literal["external"]]
    in_reply_to: Optional[InReplyTo] = None
    tracking_id: Optional[str] = None
    thread_id: Optional[str] = None
    attachments: list[Attachment]
    parent_mail: Optional[ParentMail1] = None


class FromAttendee5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ToAttendee5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class CcAttendee5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class BccAttendee5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ReplyToAttendee5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    display_name: Optional[str] = None
    profile_picture: Optional[str] = None
    identifier: str
    identifier_type: IdentifierType


class ApiV1EmailsEmailIdGetResponse3(BaseModel):
    """
    @todo Email
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Email"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[
        Literal["MAIL"],
        Literal["GOOGLE"],
        Literal["ICLOUD"],
        Literal["OUTLOOK"],
        Literal["EXCHANGE"],
        Literal["GOOGLE_OAUTH"],
    ]
    date: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    folders: list[str]
    folder_ids: list[str] = Field(..., alias="folderIds")
    read_date: Optional[Union[ReadDate, Any]] = None
    message_id: str
    provider_id: str
    from_attendee: FromAttendee5
    to_attendees: Optional[list[ToAttendee5]] = None
    cc_attendees: Optional[list[CcAttendee5]] = None
    bcc_attendees: Optional[list[BccAttendee5]] = None
    reply_to_attendees: Optional[list[ReplyToAttendee5]] = None
    subject: str
    has_attachments: bool
    origin: Union[Literal["unipile"], Literal["external"]]
    in_reply_to: Optional[InReplyTo] = None
    tracking_id: Optional[str] = None
    thread_id: Optional[str] = None
    attachments: list[Attachment]
    kind: Literal["2_full"]
    body_plain: str
    body: str
    headers: Optional[list[Header]] = None


class ApiV1EmailsEmailIdGetResponse(
    RootModel[
        Union[
            ApiV1EmailsEmailIdGetResponse1,
            ApiV1EmailsEmailIdGetResponse2,
            ApiV1EmailsEmailIdGetResponse3,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        ApiV1EmailsEmailIdGetResponse1,
        ApiV1EmailsEmailIdGetResponse2,
        ApiV1EmailsEmailIdGetResponse3,
    ] = Field(..., description="@todo Email")


class Type56(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1EmailsEmailIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type56
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type57(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1EmailsEmailIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type57
    status: Literal[403]


class Type58(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1EmailsEmailIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type58
    status: Literal[404]


class Type59(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1EmailsEmailIdGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type59
    status: Literal[500]


class Type60(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1EmailsEmailIdGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type60
    status: Literal[503]


class ApiV1EmailsEmailIdGetResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1EmailsEmailIdDeleteResponse(BaseModel):
    """
    @todo Email has been deleted.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["EmailDeleted"]


class Type61(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1EmailsEmailIdDeleteResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type61
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type62(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1EmailsEmailIdDeleteResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type62
    status: Literal[403]


class Type63(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1EmailsEmailIdDeleteResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type63
    status: Literal[404]


class Type64(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1EmailsEmailIdDeleteResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type64
    status: Literal[500]


class Type65(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1EmailsEmailIdDeleteResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type65
    status: Literal[503]


class ApiV1EmailsEmailIdDeleteResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1EmailsEmailIdPutRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    unread: Optional[bool] = Field(
        default=None,
        description="Indicates whether the email should be marked as unread.",
    )
    folders: Optional[list[str]] = Field(
        default=None,
        description="The names of the folders to which the email should be moved. Outlook and IMAP accounts accept only one folder.",
    )


class ApiV1EmailsEmailIdPutResponse(BaseModel):
    """
    @todo Email has been updated.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["EmailUpdated"]


class Type66(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1EmailsEmailIdPutResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type66
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type67(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1EmailsEmailIdPutResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type67
    status: Literal[403]


class Type68(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1EmailsEmailIdPutResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type68
    status: Literal[404]


class Type69(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1EmailsEmailIdPutResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type69
    status: Literal[500]


class Type70(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1EmailsEmailIdPutResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type70
    status: Literal[503]


class ApiV1EmailsEmailIdPutResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Type71(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1EmailsEmailIdAttachmentsAttachmentIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type71
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type72(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1EmailsEmailIdAttachmentsAttachmentIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type72
    status: Literal[403]


class Type73(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1EmailsEmailIdAttachmentsAttachmentIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type73
    status: Literal[404]


class Type74(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1EmailsEmailIdAttachmentsAttachmentIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type74
    status: Literal[500]


class Type75(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1EmailsEmailIdAttachmentsAttachmentIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type75
    status: Literal[503]


class ApiV1EmailsEmailIdAttachmentsAttachmentIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class AccountType(str, Enum):
    WHATSAPP = "WHATSAPP"
    LINKEDIN = "LINKEDIN"
    SLACK = "SLACK"
    TWITTER = "TWITTER"
    MESSENGER = "MESSENGER"
    INSTAGRAM = "INSTAGRAM"
    TELEGRAM = "TELEGRAM"


class Item(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Chat"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_type: Union[
        Literal["WHATSAPP"],
        Literal["LINKEDIN"],
        Literal["SLACK"],
        Literal["TWITTER"],
        Literal["MESSENGER"],
        Literal["INSTAGRAM"],
        Literal["TELEGRAM"],
    ]
    provider_id: str
    attendee_provider_id: Optional[str] = None
    name: Union[str, Any]
    type: Union[Literal[0], Literal[1], Literal[2]]
    timestamp: Union[str, Any]
    unread_count: float
    archived: Union[Literal[0], Literal[1]]
    muted_until: Union[Literal[-1], str, Any]
    read_only: Union[Literal[0], Literal[1], Literal[2]]
    disabled_features: Optional[
        list[Union[Literal["reactions"], Literal["reply"]]]
    ] = Field(default=None, alias="disabledFeatures")
    subject: Optional[str] = None
    organization_id: Optional[str] = Field(
        default=None, description="Linkedin specific ID for organization mailboxes."
    )
    mailbox_id: Optional[str] = Field(
        default=None, description="Linkedin specific ID for organization mailboxes."
    )
    content_type: Optional[
        Union[Literal["inmail"], Literal["sponsored"], Literal["linkedin_offer"]]
    ] = None
    folder: Optional[
        list[
            Union[
                Literal["INBOX"],
                Literal["INBOX_LINKEDIN_CLASSIC"],
                Literal["INBOX_LINKEDIN_RECRUITER"],
                Literal["INBOX_LINKEDIN_SALES_NAVIGATOR"],
                Literal["INBOX_LINKEDIN_ORGANIZATION"],
            ]
        ]
    ] = None


class ApiV1ChatsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatList"]
    items: list[Item]
    cursor: Any


class Type76(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type76
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type77(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type77
    status: Literal[403]


class Type78(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type78
    status: Literal[500]


class Type79(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type79
    status: Literal[503]


class ApiV1ChatsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Linkedin(BaseModel):
    """
    Standard Linkedin fields
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Optional[Literal["classic"]] = Field(
        default=None,
        description="The Linkedin API that should be used to start chatting (relative feature must be subscribed). Default is classic.",
    )
    applicant_id: Optional[str] = Field(
        default=None,
        description="Mandatory to start a conversation with a job applicant. Use the <strong>List all job postings</strong> route first to retrieve the job posting, and then the <strong>List all applicants to a job posting</strong> route to get the applicant details.",
    )
    inmail: Optional[bool] = Field(
        default=None,
        description="If set to true, start the new conversation with an inMail.",
    )


class Visiblity(str, Enum):
    """
    Define the level of visibility of the conversation within your organization. Default value will be PRIVATE.
    """

    PUBLIC = "PUBLIC"
    PRIVATE = "PRIVATE"
    PROJECT = "PROJECT"


class Linkedin1(BaseModel):
    """
    Recruiter Linkedin fields
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["recruiter"] = Field(
        ...,
        description="The Linkedin API that should be used to start chatting (relative feature must be subscribed).",
    )
    signature: Optional[str] = Field(
        default=None, description="The signature of the sender"
    )
    hiring_project_id: Optional[str] = Field(
        default=None, description="The ID of the project the chat should be started in"
    )
    email_address: Optional[str] = Field(
        default=None,
        description="The email address of the recipient in case the chat should be started with email instead of inMail",
    )
    visiblity: Optional[Visiblity] = Field(
        default=None,
        description="Define the level of visibility of the conversation within your organization. Default value will be PRIVATE.",
    )


class Linkedin2(BaseModel):
    """
    Sales Navigator Linkedin fields
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["sales_navigator"] = Field(
        ...,
        description="The Linkedin API that should be used to start chatting (relative features must be subscribed).",
    )


class ApiV1ChatsPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ..., description="An Unipile account id.", min_length=1, title="AccountIdParam"
    )
    text: Optional[str] = Field(
        default=None,
        description='The message that will start the new conversation.\nWith LinkedIn recruiter, a range of HTML tags can be used directly in the body of the message to enhance the presentation. The supported tags are &lt;strong&gt; for bold text, &lt;em&gt; for italic text, &lt;a href="www.my-link.com"&gt; for external links, &lt;ul&gt; for unordered lists, &lt;ol&gt; for ordered lists and &lt;li&gt; for list items. Tags can be nested into each other if necessary.',
    )
    attachments: Optional[list[bytes]] = None
    voice_message: Optional[bytes] = Field(
        default=None, description="For Linkedin messaging only."
    )
    attendees_ids: list[str] = Field(
        ..., description="One or more attendee provider ID.", min_length=1
    )
    subject: Optional[str] = Field(
        default=None,
        description="An optional field to set the subject of the conversation.",
    )
    linkedin: Optional[Union[Linkedin, Linkedin1, Linkedin2]] = Field(
        default=None, description="Extra fields for Linkedin products"
    )


class ApiV1ChatsPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatStarted"]
    chat_id: Union[str, Any] = Field(
        ..., description="The Unipile ID of the newly started chat."
    )
    message_id: Union[str, Any] = Field(
        ..., description="The Unipile ID of the message the chat started with."
    )


class Type80(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1ChatsPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type80
    status: Literal[400]


class Type81(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type81
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type82(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type82
    status: Literal[403]


class Type83(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type83
    status: Literal[404]


class ApiV1ChatsPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/unsupported_media_type"]
    status: Literal[415]


class Type84(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1ChatsPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type84
    status: Literal[422]


class ApiV1ChatsPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/too_many_requests"]
    status: Literal[429]


class Type85(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsPostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type85
    status: Literal[500]


class ApiV1ChatsPostResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type86(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsPostResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type86
    status: Literal[503]


class ApiV1ChatsPostResponse11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Size(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    width: float
    height: float


class Attachments(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Attachments5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Quoted(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments5, Attachments6, Attachments7, Attachments8, Attachments9]
    ]


class Reaction(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    value: str
    sender_id: str
    is_sender: bool


class LastMessage(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments, Attachments1, Attachments2, Attachments3, Attachments4]
    ]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_provider_id: str
    timestamp: str
    is_sender: Union[Literal[0], Literal[1]]
    quoted: Optional[Quoted] = None
    reactions: list[Reaction]
    seen: Union[Literal[0], Literal[1]]
    seen_by: dict[str, Any]
    hidden: Union[Literal[0], Literal[1]]
    deleted: Union[Literal[0], Literal[1]]
    edited: Union[Literal[0], Literal[1]]
    is_event: Union[Literal[0], Literal[1]]
    delivered: Union[Literal[0], Literal[1]]
    behavior: Union[Literal[0], Any]
    event_type: Optional[
        Union[
            Literal[0],
            Literal[1],
            Literal[2],
            Literal[3],
            Literal[4],
            Literal[5],
            Literal[6],
            Literal[7],
            Literal[8],
            Literal[9],
        ]
    ] = None
    original: str
    replies: Optional[float] = None
    reply_by: Optional[list[str]] = None
    parent: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    sender_attendee_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    subject: str


class ApiV1ChatsChatIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_type: Union[
        Literal["WHATSAPP"],
        Literal["LINKEDIN"],
        Literal["SLACK"],
        Literal["TWITTER"],
        Literal["MESSENGER"],
        Literal["INSTAGRAM"],
        Literal["TELEGRAM"],
    ]
    provider_id: str
    attendee_provider_id: Optional[str] = None
    name: Union[str, Any]
    type: Union[Literal[0], Literal[1], Literal[2]]
    timestamp: Union[str, Any]
    unread_count: float
    archived: Union[Literal[0], Literal[1]]
    muted_until: Union[Literal[-1], str, Any]
    read_only: Union[Literal[0], Literal[1], Literal[2]]
    disabled_features: Optional[
        list[Union[Literal["reactions"], Literal["reply"]]]
    ] = Field(default=None, alias="disabledFeatures")
    subject: Optional[str] = None
    organization_id: Optional[str] = Field(
        default=None, description="Linkedin specific ID for organization mailboxes."
    )
    mailbox_id: Optional[str] = Field(
        default=None, description="Linkedin specific ID for organization mailboxes."
    )
    content_type: Optional[
        Union[Literal["inmail"], Literal["sponsored"], Literal["linkedin_offer"]]
    ] = None
    folder: Optional[
        list[
            Union[
                Literal["INBOX"],
                Literal["INBOX_LINKEDIN_CLASSIC"],
                Literal["INBOX_LINKEDIN_RECRUITER"],
                Literal["INBOX_LINKEDIN_SALES_NAVIGATOR"],
                Literal["INBOX_LINKEDIN_ORGANIZATION"],
            ]
        ]
    ] = None
    object: Literal["Chat"]
    last_message: Union[LastMessage, Any] = Field(..., alias="lastMessage")


class Type87(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsChatIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type87
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type88(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsChatIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type88
    status: Literal[403]


class Type89(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsChatIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type89
    status: Literal[404]


class Type90(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsChatIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type90
    status: Literal[500]


class Type91(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsChatIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type91
    status: Literal[503]


class ApiV1ChatsChatIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1ChatsChatIdPatchRequest(BaseModel):
    """
    Set new chat read status
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    action: Literal["setReadStatus"]
    value: bool


class ApiV1ChatsChatIdPatchResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatPatched"]


class Type92(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsChatIdPatchResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type92
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type93(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsChatIdPatchResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type93
    status: Literal[403]


class Type94(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsChatIdPatchResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type94
    status: Literal[404]


class Type95(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsChatIdPatchResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type95
    status: Literal[500]


class Type96(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsChatIdPatchResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type96
    status: Literal[503]


class ApiV1ChatsChatIdPatchResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Attachments10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Attachments15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Quoted1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments15, Attachments16, Attachments17, Attachments18, Attachments19]
    ]


class Item1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Message"]
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments10, Attachments11, Attachments12, Attachments13, Attachments14]
    ]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_provider_id: str
    timestamp: str
    is_sender: Union[Literal[0], Literal[1]]
    quoted: Optional[Quoted1] = None
    reactions: list[Reaction]
    seen: Union[Literal[0], Literal[1]]
    seen_by: dict[str, Any]
    hidden: Union[Literal[0], Literal[1]]
    deleted: Union[Literal[0], Literal[1]]
    edited: Union[Literal[0], Literal[1]]
    is_event: Union[Literal[0], Literal[1]]
    delivered: Union[Literal[0], Literal[1]]
    behavior: Union[Literal[0], Any]
    event_type: Optional[
        Union[
            Literal[0],
            Literal[1],
            Literal[2],
            Literal[3],
            Literal[4],
            Literal[5],
            Literal[6],
            Literal[7],
            Literal[8],
            Literal[9],
        ]
    ] = None
    original: str
    replies: Optional[float] = None
    reply_by: Optional[list[str]] = None
    parent: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    sender_attendee_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    subject: str


class ApiV1ChatsChatIdMessagesGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["MessageList"]
    items: list[Item1]
    cursor: Any


class Type97(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsChatIdMessagesGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type97
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type98(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsChatIdMessagesGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type98
    status: Literal[403]


class Type99(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsChatIdMessagesGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type99
    status: Literal[404]


class Type100(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsChatIdMessagesGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type100
    status: Literal[500]


class Type101(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsChatIdMessagesGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type101
    status: Literal[503]


class ApiV1ChatsChatIdMessagesGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1ChatsChatIdMessagesPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    text: Optional[str] = None
    thread_id: Optional[str] = Field(
        default=None,
        description="Optional and for Slack’s messaging only. The id of a sub thread associated with a chat.",
    )
    voice_message: Optional[bytes] = Field(
        default=None, description="For Linkedin messaging only."
    )
    attachments: Optional[list[bytes]] = None


class ApiV1ChatsChatIdMessagesPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["MessageSent"]
    message_id: Union[str, Any] = Field(
        ..., description="The Unipile ID of the newly sent message."
    )


class Type102(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsChatIdMessagesPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type102
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type103(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsChatIdMessagesPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type103
    status: Literal[403]


class Type104(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsChatIdMessagesPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type104
    status: Literal[404]


class ApiV1ChatsChatIdMessagesPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/unsupported_media_type"]
    status: Literal[415]


class Type105(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1ChatsChatIdMessagesPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type105
    status: Literal[422]


class ApiV1ChatsChatIdMessagesPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/too_many_requests"]
    status: Literal[429]


class Type106(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsChatIdMessagesPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type106
    status: Literal[500]


class Type107(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsChatIdMessagesPostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type107
    status: Literal[503]


class ApiV1ChatsChatIdMessagesPostResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class SocialHandle(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: str
    name: str


class ContactInfo(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    emails: Optional[list[str]] = None
    phone_numbers: Optional[list[str]] = None
    websites: Optional[list[str]] = None
    social_handles: Optional[list[SocialHandle]] = None


class Specifics(BaseModel):
    """
    Provider specific additional data.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    member_urn: str
    occupation: Optional[str] = None
    network_distance: Optional[
        Union[
            Literal["SELF"],
            Literal["DISTANCE_1"],
            Literal["DISTANCE_2"],
            Literal["DISTANCE_3"],
            Literal["OUT_OF_NETWORK"],
        ]
    ] = None
    pending_invitation: Optional[bool] = None
    location: Optional[str] = None
    headline: Optional[str] = None
    contact_info: Optional[ContactInfo] = None


class Item2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatAttendee"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    provider_id: str
    name: str
    is_self: Union[Literal[1], Literal[0]]
    hidden: Optional[Union[Literal[1], Literal[0]]] = None
    picture_url: Optional[str] = None
    profile_url: Optional[str] = None
    specifics: Optional[Specifics] = Field(
        default=None, description="Provider specific additional data."
    )


class ApiV1ChatsChatIdAttendeesGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatAttendeeList"]
    items: list[Item2]
    cursor: Any


class Type108(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsChatIdAttendeesGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type108
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type109(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsChatIdAttendeesGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type109
    status: Literal[403]


class Type110(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsChatIdAttendeesGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type110
    status: Literal[404]


class Type111(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsChatIdAttendeesGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type111
    status: Literal[500]


class Type112(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsChatIdAttendeesGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type112
    status: Literal[503]


class ApiV1ChatsChatIdAttendeesGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Status1(str, Enum):
    """
    The status of the chat synchronization. You can setup a regular polling on the same route to get updates on its status. A new request after a SYNC_DONE or SYNC_ERROR response will start a fresh sync.
    """

    SYNC_STARTED = "SYNC_STARTED"
    SYNC_RUNNING = "SYNC_RUNNING"
    SYNC_DONE = "SYNC_DONE"
    SYNC_ERROR = "SYNC_ERROR"


class ApiV1ChatsChatIdSyncGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatHistorySync"]
    chat_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    status: Status1 = Field(
        ...,
        description="The status of the chat synchronization. You can setup a regular polling on the same route to get updates on its status. A new request after a SYNC_DONE or SYNC_ERROR response will start a fresh sync.",
    )


class Type113(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatsChatIdSyncGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type113
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type114(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatsChatIdSyncGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type114
    status: Literal[403]


class Type115(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatsChatIdSyncGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type115
    status: Literal[404]


class Type116(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1ChatsChatIdSyncGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type116
    status: Literal[422]


class Type117(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatsChatIdSyncGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type117
    status: Literal[500]


class ApiV1ChatsChatIdSyncGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type118(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatsChatIdSyncGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type118
    status: Literal[503]


class ApiV1ChatsChatIdSyncGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Attachments20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments21(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments22(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments23(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments24(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Attachments25(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments26(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments27(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments28(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments29(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Quoted2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments25, Attachments26, Attachments27, Attachments28, Attachments29]
    ]


class ApiV1MessagesIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments20, Attachments21, Attachments22, Attachments23, Attachments24]
    ]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_provider_id: str
    timestamp: str
    is_sender: Union[Literal[0], Literal[1]]
    quoted: Optional[Quoted2] = None
    reactions: list[Reaction]
    seen: Union[Literal[0], Literal[1]]
    seen_by: dict[str, Any]
    hidden: Union[Literal[0], Literal[1]]
    deleted: Union[Literal[0], Literal[1]]
    edited: Union[Literal[0], Literal[1]]
    is_event: Union[Literal[0], Literal[1]]
    delivered: Union[Literal[0], Literal[1]]
    behavior: Union[Literal[0], Any]
    event_type: Optional[
        Union[
            Literal[0],
            Literal[1],
            Literal[2],
            Literal[3],
            Literal[4],
            Literal[5],
            Literal[6],
            Literal[7],
            Literal[8],
            Literal[9],
        ]
    ] = None
    original: str
    replies: Optional[float] = None
    reply_by: Optional[list[str]] = None
    parent: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    sender_attendee_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    subject: str
    object: Literal["Message"]


class Type119(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1MessagesIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type119
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type120(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1MessagesIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type120
    status: Literal[403]


class Type121(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1MessagesIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type121
    status: Literal[404]


class Type122(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1MessagesIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type122
    status: Literal[500]


class Type123(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1MessagesIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type123
    status: Literal[503]


class ApiV1MessagesIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Attachments30(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments31(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments32(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments33(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments34(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Attachments35(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments36(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments37(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments38(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments39(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Quoted3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments35, Attachments36, Attachments37, Attachments38, Attachments39]
    ]


class Item3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Message"]
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments30, Attachments31, Attachments32, Attachments33, Attachments34]
    ]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_provider_id: str
    timestamp: str
    is_sender: Union[Literal[0], Literal[1]]
    quoted: Optional[Quoted3] = None
    reactions: list[Reaction]
    seen: Union[Literal[0], Literal[1]]
    seen_by: dict[str, Any]
    hidden: Union[Literal[0], Literal[1]]
    deleted: Union[Literal[0], Literal[1]]
    edited: Union[Literal[0], Literal[1]]
    is_event: Union[Literal[0], Literal[1]]
    delivered: Union[Literal[0], Literal[1]]
    behavior: Union[Literal[0], Any]
    event_type: Optional[
        Union[
            Literal[0],
            Literal[1],
            Literal[2],
            Literal[3],
            Literal[4],
            Literal[5],
            Literal[6],
            Literal[7],
            Literal[8],
            Literal[9],
        ]
    ] = None
    original: str
    replies: Optional[float] = None
    reply_by: Optional[list[str]] = None
    parent: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    sender_attendee_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    subject: str


class ApiV1MessagesGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["MessageList"]
    items: list[Item3]
    cursor: Any


class Type124(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1MessagesGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type124
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type125(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1MessagesGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type125
    status: Literal[403]


class Type126(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1MessagesGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type126
    status: Literal[404]


class Type127(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1MessagesGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type127
    status: Literal[500]


class Type128(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1MessagesGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type128
    status: Literal[503]


class ApiV1MessagesGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Type129(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1MessagesMessageIdAttachmentsAttachmentIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type129
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type130(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1MessagesMessageIdAttachmentsAttachmentIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type130
    status: Literal[403]


class Type131(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1MessagesMessageIdAttachmentsAttachmentIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type131
    status: Literal[404]


class Type132(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1MessagesMessageIdAttachmentsAttachmentIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type132
    status: Literal[500]


class Type133(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1MessagesMessageIdAttachmentsAttachmentIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type133
    status: Literal[503]


class ApiV1MessagesMessageIdAttachmentsAttachmentIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ContactInfo1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    emails: Optional[list[str]] = None
    phone_numbers: Optional[list[str]] = None
    websites: Optional[list[str]] = None
    social_handles: Optional[list[SocialHandle]] = None


class Specifics1(BaseModel):
    """
    Provider specific additional data.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    member_urn: str
    occupation: Optional[str] = None
    network_distance: Optional[
        Union[
            Literal["SELF"],
            Literal["DISTANCE_1"],
            Literal["DISTANCE_2"],
            Literal["DISTANCE_3"],
            Literal["OUT_OF_NETWORK"],
        ]
    ] = None
    pending_invitation: Optional[bool] = None
    location: Optional[str] = None
    headline: Optional[str] = None
    contact_info: Optional[ContactInfo1] = None


class Item4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatAttendee"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    provider_id: str
    name: str
    is_self: Union[Literal[1], Literal[0]]
    hidden: Optional[Union[Literal[1], Literal[0]]] = None
    picture_url: Optional[str] = None
    profile_url: Optional[str] = None
    specifics: Optional[Specifics1] = Field(
        default=None, description="Provider specific additional data."
    )


class ApiV1ChatAttendeesGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatAttendeeList"]
    items: list[Item4]
    cursor: Any


class Type134(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatAttendeesGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type134
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type135(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatAttendeesGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type135
    status: Literal[403]


class Type136(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatAttendeesGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type136
    status: Literal[404]


class Type137(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatAttendeesGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type137
    status: Literal[500]


class Type138(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatAttendeesGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type138
    status: Literal[503]


class ApiV1ChatAttendeesGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ContactInfo2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    emails: Optional[list[str]] = None
    phone_numbers: Optional[list[str]] = None
    websites: Optional[list[str]] = None
    social_handles: Optional[list[SocialHandle]] = None


class Specifics2(BaseModel):
    """
    Provider specific additional data.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    member_urn: str
    occupation: Optional[str] = None
    network_distance: Optional[
        Union[
            Literal["SELF"],
            Literal["DISTANCE_1"],
            Literal["DISTANCE_2"],
            Literal["DISTANCE_3"],
            Literal["OUT_OF_NETWORK"],
        ]
    ] = None
    pending_invitation: Optional[bool] = None
    location: Optional[str] = None
    headline: Optional[str] = None
    contact_info: Optional[ContactInfo2] = None


class ApiV1ChatAttendeesIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    provider_id: str
    name: str
    is_self: Union[Literal[1], Literal[0]]
    hidden: Optional[Union[Literal[1], Literal[0]]] = None
    picture_url: Optional[str] = None
    profile_url: Optional[str] = None
    specifics: Optional[Specifics2] = Field(
        default=None, description="Provider specific additional data."
    )
    object: Literal["ChatAttendee"]


class Type139(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatAttendeesIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type139
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type140(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatAttendeesIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type140
    status: Literal[403]


class Type141(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatAttendeesIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type141
    status: Literal[404]


class Type142(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatAttendeesIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type142
    status: Literal[500]


class Type143(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatAttendeesIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type143
    status: Literal[503]


class ApiV1ChatAttendeesIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Type144(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatAttendeesIdPictureGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type144
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type145(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatAttendeesIdPictureGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type145
    status: Literal[403]


class Type146(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatAttendeesIdPictureGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type146
    status: Literal[500]


class Type147(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatAttendeesIdPictureGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type147
    status: Literal[503]


class ApiV1ChatAttendeesIdPictureGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Chat"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_type: Union[
        Literal["WHATSAPP"],
        Literal["LINKEDIN"],
        Literal["SLACK"],
        Literal["TWITTER"],
        Literal["MESSENGER"],
        Literal["INSTAGRAM"],
        Literal["TELEGRAM"],
    ]
    provider_id: str
    attendee_provider_id: Optional[str] = None
    name: Union[str, Any]
    type: Union[Literal[0], Literal[1], Literal[2]]
    timestamp: Union[str, Any]
    unread_count: float
    archived: Union[Literal[0], Literal[1]]
    muted_until: Union[Literal[-1], str, Any]
    read_only: Union[Literal[0], Literal[1], Literal[2]]
    disabled_features: Optional[
        list[Union[Literal["reactions"], Literal["reply"]]]
    ] = Field(default=None, alias="disabledFeatures")
    subject: Optional[str] = None
    organization_id: Optional[str] = Field(
        default=None, description="Linkedin specific ID for organization mailboxes."
    )
    mailbox_id: Optional[str] = Field(
        default=None, description="Linkedin specific ID for organization mailboxes."
    )
    content_type: Optional[
        Union[Literal["inmail"], Literal["sponsored"], Literal["linkedin_offer"]]
    ] = None
    folder: Optional[
        list[
            Union[
                Literal["INBOX"],
                Literal["INBOX_LINKEDIN_CLASSIC"],
                Literal["INBOX_LINKEDIN_RECRUITER"],
                Literal["INBOX_LINKEDIN_SALES_NAVIGATOR"],
                Literal["INBOX_LINKEDIN_ORGANIZATION"],
            ]
        ]
    ] = None


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ChatList"]
    items: list[Item5]
    cursor: Any


class Type148(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type148
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type149(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type149
    status: Literal[403]


class Type150(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type150
    status: Literal[404]


class Type151(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type151
    status: Literal[500]


class Type152(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type152
    status: Literal[503]


class ApiV1ChatAttendeesAttendeeIdChatsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Attachments40(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments41(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments42(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments43(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments44(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Attachments45(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments46(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments47(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments48(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments49(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Quoted4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments45, Attachments46, Attachments47, Attachments48, Attachments49]
    ]


class Item6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Message"]
    provider_id: str
    sender_id: str
    text: Union[str, Any]
    attachments: list[
        Union[Attachments40, Attachments41, Attachments42, Attachments43, Attachments44]
    ]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    chat_provider_id: str
    timestamp: str
    is_sender: Union[Literal[0], Literal[1]]
    quoted: Optional[Quoted4] = None
    reactions: list[Reaction]
    seen: Union[Literal[0], Literal[1]]
    seen_by: dict[str, Any]
    hidden: Union[Literal[0], Literal[1]]
    deleted: Union[Literal[0], Literal[1]]
    edited: Union[Literal[0], Literal[1]]
    is_event: Union[Literal[0], Literal[1]]
    delivered: Union[Literal[0], Literal[1]]
    behavior: Union[Literal[0], Any]
    event_type: Optional[
        Union[
            Literal[0],
            Literal[1],
            Literal[2],
            Literal[3],
            Literal[4],
            Literal[5],
            Literal[6],
            Literal[7],
            Literal[8],
            Literal[9],
        ]
    ] = None
    original: str
    replies: Optional[float] = None
    reply_by: Optional[list[str]] = None
    parent: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    sender_attendee_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    subject: str


class ApiV1ChatAttendeesSenderIdMessagesGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["MessageList"]
    items: list[Item6]
    cursor: Any


class Type153(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1ChatAttendeesSenderIdMessagesGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type153
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type154(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1ChatAttendeesSenderIdMessagesGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type154
    status: Literal[403]


class Type155(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1ChatAttendeesSenderIdMessagesGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type155
    status: Literal[404]


class Type156(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1ChatAttendeesSenderIdMessagesGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type156
    status: Literal[500]


class Type157(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1ChatAttendeesSenderIdMessagesGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type157
    status: Literal[503]


class ApiV1ChatAttendeesSenderIdMessagesGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class AccountId(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: Optional[str] = None
    type: Union[
        Literal["GOOGLE"],
        Literal["GOOGLE_CALENDAR"],
        Literal["ICLOUD"],
        Literal["LINKEDIN"],
        Literal["MAIL"],
        Literal["MOBILE"],
        Literal["OUTLOOK"],
        Literal["TWITTER"],
        Literal["WHATSAPP"],
        Literal["SLACK"],
        Literal["TELEGRAM"],
    ]


class Format(str, Enum):
    """
    The format of data you recieve from the webhook. Accepted values: json | form
    """

    JSON = "json"
    FORM = "form"


class Header2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    key: str
    value: str


class Key(str, Enum):
    ACCOUNT_ID = "account_id"
    ACCOUNT_TYPE = "account_type"
    ACCOUNT_INFO = "account_info"
    CHAT_ID = "chat_id"
    TIMESTAMP = "timestamp"
    WEBHOOK_NAME = "webhook_name"
    MESSAGE_ID = "message_id"
    MESSAGE = "message"
    REACTION = "reaction"
    REACTION_SENDER = "reaction_sender"
    SENDER = "sender"
    ATTENDEES = "attendees"
    ATTACHMENTS = "attachments"
    SUBJECT = "subject"
    PROVIDER_CHAT_ID = "provider_chat_id"
    PROVIDER_MESSAGE_ID = "provider_message_id"


class Datum(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key


class Key1(str, Enum):
    EMAIL_ID = "email_id"
    ACCOUNT_ID = "account_id"
    WEBHOOK_NAME = "webhook_name"
    DATE = "date"
    FROM_ATTENDEE = "from_attendee"
    TO_ATTENDEES = "to_attendees"
    CC_ATTENDEES = "cc_attendees"
    BCC_ATTENDEES = "bcc_attendees"
    REPLY_TO_ATTENDEES = "reply_to_attendees"
    SUBJECT = "subject"
    BODY = "body"
    BODY_PLAIN = "body_plain"
    MESSAGE_ID = "message_id"
    PROVIDER_ID = "provider_id"
    TRACKING_ID = "tracking_id"
    READ_DATE = "read_date"
    IS_COMPLETE = "is_complete"
    IN_REPLY_TO = "in_reply_to"
    HAS_ATTACHMENTS = "has_attachments"
    ATTACHMENTS = "attachments"
    FOLDERS = "folders"
    ROLE = "role"
    ORIGIN = "origin"


class Datum1(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key1


class Key2(str, Enum):
    EVENT_ID = "event_id"
    TRACKING_ID = "tracking_id"
    TYPE = "type"
    DATE = "date"
    EMAIL_ID = "email_id"
    ACCOUNT_ID = "account_id"
    IP = "ip"
    USER_AGENT = "user_agent"
    URL = "url"
    LABEL = "label"
    CUSTOM_DOMAIN = "custom_domain"


class Datum2(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key2


class Events(str, Enum):
    MESSAGE_RECEIVED = "message_received"
    MESSAGE_READ = "message_read"
    MESSAGE_REACTION = "message_reaction"


class Events1(str, Enum):
    MAIL_SENT = "mail_sent"
    MAIL_RECEIVED = "mail_received"


class Events2(str, Enum):
    MAIL_OPENED = "mail_opened"
    MAIL_LINK_CLICKED = "mail_link_clicked"


class Events3(str, Enum):
    CREATION_SUCCESS = "creation_success"
    CREATION_FAIL = "creation_fail"
    DELETED = "deleted"
    RECONNECTED = "reconnected"
    SYNC_SUCCESS = "sync_success"
    STOPPED = "stopped"
    OK = "ok"
    CONNECTING = "connecting"
    ERROR = "error"
    CREDENTIALS = "credentials"
    PERMISSIONS = "permissions"


class Items17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Webhook"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_ids: list[AccountId]
    enabled: bool
    name: Optional[str] = None
    request_url: str
    format: Format = Field(
        ...,
        description="The format of data you recieve from the webhook. Accepted values: json | form",
        examples=["json"],
    )
    headers: list[Header2]
    data: Union[list[Datum], list[Datum1], list[Datum2]]
    events: Optional[list[Union[Events, Events1, Events2, Events3]]] = None
    type: Literal["AUTO"]


class Key3(str, Enum):
    ACCOUNT_ID = "account_id"
    ACCOUNT_TYPE = "account_type"
    ACCOUNT_INFO = "account_info"
    CHAT_ID = "chat_id"
    TIMESTAMP = "timestamp"
    WEBHOOK_NAME = "webhook_name"
    MESSAGE_ID = "message_id"
    MESSAGE = "message"
    REACTION = "reaction"
    REACTION_SENDER = "reaction_sender"
    SENDER = "sender"
    ATTENDEES = "attendees"
    ATTACHMENTS = "attachments"
    SUBJECT = "subject"
    PROVIDER_CHAT_ID = "provider_chat_id"
    PROVIDER_MESSAGE_ID = "provider_message_id"


class Datum3(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key3


class Key4(str, Enum):
    EMAIL_ID = "email_id"
    ACCOUNT_ID = "account_id"
    WEBHOOK_NAME = "webhook_name"
    DATE = "date"
    FROM_ATTENDEE = "from_attendee"
    TO_ATTENDEES = "to_attendees"
    CC_ATTENDEES = "cc_attendees"
    BCC_ATTENDEES = "bcc_attendees"
    REPLY_TO_ATTENDEES = "reply_to_attendees"
    SUBJECT = "subject"
    BODY = "body"
    BODY_PLAIN = "body_plain"
    MESSAGE_ID = "message_id"
    PROVIDER_ID = "provider_id"
    TRACKING_ID = "tracking_id"
    READ_DATE = "read_date"
    IS_COMPLETE = "is_complete"
    IN_REPLY_TO = "in_reply_to"
    HAS_ATTACHMENTS = "has_attachments"
    ATTACHMENTS = "attachments"
    FOLDERS = "folders"
    ROLE = "role"
    ORIGIN = "origin"


class Datum4(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key4


class Key5(str, Enum):
    EVENT_ID = "event_id"
    TRACKING_ID = "tracking_id"
    TYPE = "type"
    DATE = "date"
    EMAIL_ID = "email_id"
    ACCOUNT_ID = "account_id"
    IP = "ip"
    USER_AGENT = "user_agent"
    URL = "url"
    LABEL = "label"
    CUSTOM_DOMAIN = "custom_domain"


class Datum5(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key5


class Events4(str, Enum):
    MESSAGE_RECEIVED = "message_received"
    MESSAGE_READ = "message_read"
    MESSAGE_REACTION = "message_reaction"


class Events5(str, Enum):
    MAIL_SENT = "mail_sent"
    MAIL_RECEIVED = "mail_received"


class Events6(str, Enum):
    MAIL_OPENED = "mail_opened"
    MAIL_LINK_CLICKED = "mail_link_clicked"


class Events7(str, Enum):
    CREATION_SUCCESS = "creation_success"
    CREATION_FAIL = "creation_fail"
    DELETED = "deleted"
    RECONNECTED = "reconnected"
    SYNC_SUCCESS = "sync_success"
    STOPPED = "stopped"
    OK = "ok"
    CONNECTING = "connecting"
    ERROR = "error"
    CREDENTIALS = "credentials"
    PERMISSIONS = "permissions"


class Trigger(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    icon: Union[
        Literal["WebhookIcon"],
        Literal["SettingsInputIcon"],
        Literal["LeakAddIcon"],
        Literal["Diversity2Icon"],
        Literal["AutoFixHighIcon"],
        Literal["SignPostIcon"],
        Literal["ShutterSpeedIcon"],
        Literal["SyncAltIcon"],
        Literal["WhatsAppIcon"],
        Literal["LinkedInIcon"],
        Literal["ImportExportIcon"],
        Literal["PodcastsIcon"],
        Literal["CableIcon"],
    ]
    name: str
    context: Union[Literal["MESSAGE"], Literal["CHAT"]]


class Items18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Webhook"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    account_ids: list[AccountId]
    enabled: bool
    name: Optional[str] = None
    request_url: str
    format: Format = Field(
        ...,
        description="The format of data you recieve from the webhook. Accepted values: json | form",
        examples=["json"],
    )
    headers: list[Header2]
    data: Union[list[Datum3], list[Datum4], list[Datum5]]
    events: Optional[list[Union[Events4, Events5, Events6, Events7]]] = None
    type: Literal["TRIGGER"]
    trigger: Trigger


class ApiV1WebhooksGetResponse(BaseModel):
    """
    @todo
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["WebhookList"]
    items: list[Union[Items17, Items18]]
    cursor: Any


class Type158(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1WebhooksGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type158
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type159(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1WebhooksGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type159
    status: Literal[403]


class Type160(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1WebhooksGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type160
    status: Literal[500]


class Type161(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1WebhooksGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type161
    status: Literal[503]


class ApiV1WebhooksGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Event(str, Enum):
    MESSAGE_RECEIVED = "message_received"
    MESSAGE_READ = "message_read"
    MESSAGE_REACTION = "message_reaction"


class Key6(str, Enum):
    ACCOUNT_ID = "account_id"
    ACCOUNT_TYPE = "account_type"
    ACCOUNT_INFO = "account_info"
    CHAT_ID = "chat_id"
    TIMESTAMP = "timestamp"
    WEBHOOK_NAME = "webhook_name"
    MESSAGE_ID = "message_id"
    MESSAGE = "message"
    REACTION = "reaction"
    REACTION_SENDER = "reaction_sender"
    SENDER = "sender"
    ATTENDEES = "attendees"
    ATTACHMENTS = "attachments"
    SUBJECT = "subject"
    PROVIDER_CHAT_ID = "provider_chat_id"
    PROVIDER_MESSAGE_ID = "provider_message_id"


class Datum6(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key6


class ApiV1WebhooksPostRequest1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    request_url: str = Field(..., description="The url to associate with the webhook.")
    name: Optional[str] = Field(
        default=None,
        description="This field will be sent back to you in the notify_url to help match the added account with your user.",
    )
    format: Optional[Format] = Field(
        default=None,
        description="The format of data you recieve from the webhook. Accepted values: json | form",
        examples=["json"],
    )
    account_ids: Optional[list[str]] = Field(
        default=None,
        description="An optional list of account ids to be targeted by the webhook. If not set, the webhook will apply to all current and future accounts connected to Unipile.",
    )
    enabled: Optional[bool] = Field(
        default=None, description="A boolean to activate or disable the webhook."
    )
    headers: Optional[list[Header2]] = Field(
        default=None,
        description="An optional field to add some headers to the webhook.",
    )
    source: Literal["messaging"] = Field(
        ...,
        description="A litteral to pick the kind of data you expect to receive from the webhook.",
    )
    events: Optional[list[Event]] = Field(
        default=None,
        description='An array of events on which the webhook should be triggered. Default value include "message_received".',
    )
    data: Optional[list[Datum6]] = None


class Event1(str, Enum):
    CREATION_SUCCESS = "creation_success"
    CREATION_FAIL = "creation_fail"
    DELETED = "deleted"
    RECONNECTED = "reconnected"
    SYNC_SUCCESS = "sync_success"
    STOPPED = "stopped"
    OK = "ok"
    CONNECTING = "connecting"
    ERROR = "error"
    CREDENTIALS = "credentials"
    PERMISSIONS = "permissions"


class ApiV1WebhooksPostRequest2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    request_url: str = Field(..., description="The url to associate with the webhook.")
    name: Optional[str] = Field(
        default=None,
        description="This field will be sent back to you in the notify_url to help match the added account with your user.",
    )
    format: Optional[Format] = Field(
        default=None,
        description="The format of data you recieve from the webhook. Accepted values: json | form",
        examples=["json"],
    )
    account_ids: Optional[list[str]] = Field(
        default=None,
        description="An optional list of account ids to be targeted by the webhook. If not set, the webhook will apply to all current and future accounts connected to Unipile.",
    )
    enabled: Optional[bool] = Field(
        default=None, description="A boolean to activate or disable the webhook."
    )
    headers: Optional[list[Header2]] = Field(
        default=None,
        description="An optional field to add some headers to the webhook.",
    )
    source: Literal["account_status"] = Field(
        ...,
        description="A litteral to pick the kind of data you expect to receive from the webhook.",
    )
    events: Optional[list[Event1]] = Field(
        default=None,
        description="An array of events on which the webhook should be triggered. Default settings cover the usual statuses, except for CONNECTING, OK and STOPPED.",
    )


class Event2(str, Enum):
    MAIL_SENT = "mail_sent"
    MAIL_RECEIVED = "mail_received"


class Key7(str, Enum):
    EMAIL_ID = "email_id"
    ACCOUNT_ID = "account_id"
    WEBHOOK_NAME = "webhook_name"
    DATE = "date"
    FROM_ATTENDEE = "from_attendee"
    TO_ATTENDEES = "to_attendees"
    CC_ATTENDEES = "cc_attendees"
    BCC_ATTENDEES = "bcc_attendees"
    REPLY_TO_ATTENDEES = "reply_to_attendees"
    SUBJECT = "subject"
    BODY = "body"
    BODY_PLAIN = "body_plain"
    MESSAGE_ID = "message_id"
    PROVIDER_ID = "provider_id"
    TRACKING_ID = "tracking_id"
    READ_DATE = "read_date"
    IS_COMPLETE = "is_complete"
    IN_REPLY_TO = "in_reply_to"
    HAS_ATTACHMENTS = "has_attachments"
    ATTACHMENTS = "attachments"
    FOLDERS = "folders"
    ROLE = "role"
    ORIGIN = "origin"


class Datum7(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key7


class ApiV1WebhooksPostRequest3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    request_url: str = Field(..., description="The url to associate with the webhook.")
    name: Optional[str] = Field(
        default=None,
        description="This field will be sent back to you in the notify_url to help match the added account with your user.",
    )
    format: Optional[Format] = Field(
        default=None,
        description="The format of data you recieve from the webhook. Accepted values: json | form",
        examples=["json"],
    )
    account_ids: Optional[list[str]] = Field(
        default=None,
        description="An optional list of account ids to be targeted by the webhook. If not set, the webhook will apply to all current and future accounts connected to Unipile.",
    )
    enabled: Optional[bool] = Field(
        default=None, description="A boolean to activate or disable the webhook."
    )
    headers: Optional[list[Header2]] = Field(
        default=None,
        description="An optional field to add some headers to the webhook.",
    )
    source: Literal["email"] = Field(
        ...,
        description="A litteral to pick the kind of data you expect to receive from the webhook.",
    )
    events: Optional[list[Event2]] = Field(
        default=None,
        description='An array of events on which the webhook should be triggered. Default value include "mail_received".',
    )
    data: Optional[list[Datum7]] = None


class Event3(str, Enum):
    MAIL_OPENED = "mail_opened"
    MAIL_LINK_CLICKED = "mail_link_clicked"


class Key8(str, Enum):
    EVENT_ID = "event_id"
    TRACKING_ID = "tracking_id"
    TYPE = "type"
    DATE = "date"
    EMAIL_ID = "email_id"
    ACCOUNT_ID = "account_id"
    IP = "ip"
    USER_AGENT = "user_agent"
    URL = "url"
    LABEL = "label"
    CUSTOM_DOMAIN = "custom_domain"


class Datum8(BaseModel):
    """
    You can use this field to change the name of the properties you will receive from the webhook.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str = Field(
        ...,
        description="The name of the property you want to receive. It will replace the original name of the property.",
    )
    key: Key8


class ApiV1WebhooksPostRequest4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    request_url: str = Field(..., description="The url to associate with the webhook.")
    name: Optional[str] = Field(
        default=None,
        description="This field will be sent back to you in the notify_url to help match the added account with your user.",
    )
    format: Optional[Format] = Field(
        default=None,
        description="The format of data you recieve from the webhook. Accepted values: json | form",
        examples=["json"],
    )
    account_ids: Optional[list[str]] = Field(
        default=None,
        description="An optional list of account ids to be targeted by the webhook. If not set, the webhook will apply to all current and future accounts connected to Unipile.",
    )
    enabled: Optional[bool] = Field(
        default=None, description="A boolean to activate or disable the webhook."
    )
    headers: Optional[list[Header2]] = Field(
        default=None,
        description="An optional field to add some headers to the webhook.",
    )
    source: Literal["email_tracking"] = Field(
        ...,
        description="A litteral to pick the kind of data you expect to receive from the webhook.",
    )
    events: Optional[list[Event3]] = Field(
        default=None,
        description='An array of events on which the webhook should be triggered. Default value include "mail_opened".',
    )
    data: Optional[list[Datum8]] = None


class ApiV1WebhooksPostRequest(
    RootModel[
        Union[
            ApiV1WebhooksPostRequest1,
            ApiV1WebhooksPostRequest2,
            ApiV1WebhooksPostRequest3,
            ApiV1WebhooksPostRequest4,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        ApiV1WebhooksPostRequest1,
        ApiV1WebhooksPostRequest2,
        ApiV1WebhooksPostRequest3,
        ApiV1WebhooksPostRequest4,
    ]


class ApiV1WebhooksPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["WebhookCreated"]
    webhook_id: str


class Type162(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1WebhooksPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type162
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type163(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1WebhooksPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type163
    status: Literal[403]


class Type164(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1WebhooksPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type164
    status: Literal[500]


class Type165(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1WebhooksPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type165
    status: Literal[503]


class ApiV1WebhooksPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1WebhooksIdDeleteResponse(BaseModel):
    """
    @todo
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["WebhookDeleted"]


class Type166(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1WebhooksIdDeleteResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type166
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type167(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1WebhooksIdDeleteResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type167
    status: Literal[403]


class Type168(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1WebhooksIdDeleteResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type168
    status: Literal[404]


class Type169(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1WebhooksIdDeleteResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type169
    status: Literal[500]


class Type170(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1WebhooksIdDeleteResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type170
    status: Literal[503]


class ApiV1WebhooksIdDeleteResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Folder"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    nb_mails: Optional[float] = None
    provider_id: str


class ApiV1FoldersGetResponse(BaseModel):
    """
    @todo List of Folders.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["FolderList"]
    items: list[Item7]


class Type171(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1FoldersGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type171
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type172(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1FoldersGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type172
    status: Literal[403]


class Type173(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1FoldersGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type173
    status: Literal[404]


class Type174(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1FoldersGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type174
    status: Literal[500]


class Type175(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1FoldersGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type175
    status: Literal[503]


class ApiV1FoldersGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1FoldersFolderIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Folder"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    name: str
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    role: Union[
        Literal["inbox"],
        Literal["sent"],
        Literal["archive"],
        Literal["drafts"],
        Literal["trash"],
        Literal["spam"],
        Literal["all"],
        Literal["important"],
        Literal["starred"],
        Literal["unknown"],
    ]
    nb_mails: Optional[float] = None
    provider_id: str


class Type176(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1FoldersFolderIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type176
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type177(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1FoldersFolderIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type177
    status: Literal[403]


class Type178(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1FoldersFolderIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type178
    status: Literal[404]


class Type179(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1FoldersFolderIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type179
    status: Literal[500]


class Type180(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1FoldersFolderIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type180
    status: Literal[503]


class ApiV1FoldersFolderIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Inviter(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    inviter_name: str
    inviter_id: str
    inviter_public_identifier: str
    inviter_description: Union[str, Any]


class Specifics3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    shared_secret: str


class Item8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["InvitationSent"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    invited_user: Union[str, Any]
    invited_user_id: Union[str, Any]
    invited_user_public_id: Union[str, Any]
    invited_user_description: Union[str, Any]
    date: str
    parsed_datetime: Union[str, Any]
    invitation_text: Union[str, Any]
    inviter: Optional[Inviter] = None
    specifics: Optional[Specifics3] = None


class ApiV1UsersInviteSentGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["InvitationList"]
    items: list[Item8]
    cursor: Union[str, Any]


class Type181(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersInviteSentGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type181
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type182(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersInviteSentGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type182
    status: Literal[403]


class Type183(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersInviteSentGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type183
    status: Literal[500]


class Type184(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersInviteSentGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type184
    status: Literal[503]


class ApiV1UsersInviteSentGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["InvitationReceived"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    invited_user: Union[str, Any]
    invited_user_id: Union[str, Any]
    invited_user_public_id: Union[str, Any]
    invited_user_description: Union[str, Any]
    date: str
    parsed_datetime: Union[str, Any]
    invitation_text: Union[str, Any]
    inviter: Optional[Inviter] = None
    specifics: Optional[Specifics3] = None


class ApiV1UsersInviteReceivedGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["InvitationList"]
    items: list[Item9]
    cursor: Union[str, Any]


class Type185(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersInviteReceivedGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type185
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type186(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersInviteReceivedGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type186
    status: Literal[403]


class Type187(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersInviteReceivedGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type187
    status: Literal[500]


class Type188(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersInviteReceivedGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type188
    status: Literal[503]


class ApiV1UsersInviteReceivedGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Action(str, Enum):
    ACCEPT = "accept"
    DECLINE = "decline"


class ApiV1UsersInviteReceivedInvitationIdPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    shared_secret: str = Field(
        ...,
        description="This token provided by Linkedin is mandatory to handle received invitations. It can be retrieved along with each invitation using the List all invitations received route.",
        min_length=1,
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    action: Action


class ApiV1UsersInviteReceivedInvitationIdPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["UserInvitationHandled"]
    status: Union[Literal["ACCEPTED"], Literal["DECLINED"]]


class Type189(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersInviteReceivedInvitationIdPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type189
    status: Literal[401]
    connection_params: Optional[ConnectionParams29] = Field(
        default=None, alias="connectionParams"
    )


class Type190(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersInviteReceivedInvitationIdPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type190
    status: Literal[403]


class Type191(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersInviteReceivedInvitationIdPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type191
    status: Literal[500]


class Type192(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersInviteReceivedInvitationIdPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type192
    status: Literal[503]


class ApiV1UsersInviteReceivedInvitationIdPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Organization2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    mailbox_id: str
    name: str


class Recruiter(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    owner_seat_id: str
    contract_id: str


class Recruiter1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    error: Union[Literal["MULTIPLE_SESSIONS"], Literal["DISCONNECTED"]]


class SalesNavigator(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    owner_seat_id: str
    contract_id: str


class SalesNavigator1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    error: Literal["DISCONNECTED"]


class ApiV1UsersMeGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    provider_id: str
    entity_urn: str
    object_urn: str
    first_name: str
    last_name: str
    profile_picture_url: Union[str, Any]
    public_profile_url: Optional[str] = None
    public_identifier: Optional[str] = None
    headline: Optional[str] = None
    location: Optional[str] = None
    email: str
    premium: bool
    open_profile: bool
    occupation: Optional[str] = None
    organizations: list[Organization2]
    recruiter: Union[Recruiter, Recruiter1, Any]
    sales_navigator: Union[SalesNavigator, SalesNavigator1, Any]
    object: Literal["AccountOwnerProfile"]


class Status2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    expires: Optional[float] = None
    was_online: Optional[float] = None


class RestrictionReasonItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    platform: str
    reason: str
    text: str


class ApiV1UsersMeGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["TELEGRAM"]
    provider_id: str
    self: Optional[Union[bool, Any]] = None
    contact: Optional[Union[bool, Any]] = None
    mutual_contact: Optional[Union[bool, Any]] = None
    deleted: Optional[Union[bool, Any]] = None
    bot: Optional[Union[bool, Any]] = None
    verified: Optional[Union[bool, Any]] = None
    restricted: Optional[Union[bool, Any]] = None
    fake: Optional[Union[bool, Any]] = None
    premium: Optional[Union[bool, Any]] = None
    close_friend: Optional[Union[bool, Any]] = None
    first_name: Optional[Union[str, Any]] = None
    last_name: Optional[Union[str, Any]] = None
    username: Optional[Union[str, Any]] = None
    phone: Optional[Union[str, Any]] = None
    profile_picture_url: str
    status: Optional[Union[Status2, Any]] = None
    restriction_reason: Optional[Union[list[RestrictionReasonItem], Any]] = None
    lang_code: Optional[Union[str, Any]] = None
    object: Literal["AccountOwnerProfile"]


class Description(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    urls: list


class Entities(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    description: Description


class ApiV1UsersMeGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["TWITTER"]
    id: str
    name: str
    screen_name: str
    location: str
    description: Union[Any, str]
    url: Union[Any, str]
    entities: Entities
    protected: bool
    verified: bool
    followers_count: float
    friends_count: float
    listed_count: float
    favourites_count: float
    statuses_count: float
    created_at: str
    profile_banner_url: Optional[Union[str, Any]] = None
    profile_image_url_https: str
    default_profile: bool
    default_profile_image: bool
    withheld_in_countries: list[str]
    followed_by: Optional[Union[Any, bool]] = None
    following: Optional[Union[Any, bool]] = None
    follow_request_sent: Optional[Union[Any, bool]] = None
    has_extended_profile: Optional[Union[Any, bool]] = None
    notifications: Optional[Union[Any, bool]] = None
    advertiser_account_type: Optional[Union[Any, str]] = None
    business_profile_state: Optional[Union[Any, str]] = None
    require_some_consent: Optional[Union[Any, bool]] = None
    object: Literal["AccountOwnerProfile"]


class Alias(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    email: str
    display_name: Optional[str] = None
    reply_to: Optional[str] = None
    signature: Optional[str] = None
    is_primary: Optional[bool] = None
    is_default: Optional[bool] = None
    verification_status: Optional[str] = None


class ApiV1UsersMeGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["GMAIL"]
    email: str
    messages_total: Optional[float] = None
    threads_total: Optional[float] = None
    aliases: list[Alias]
    object: Literal["AccountOwnerProfile"]


class ApiV1UsersMeGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["OUTLOOK"]
    id: str
    email: str
    display_name: str
    given_name: str
    surname: str
    user_principal_name: str
    job_title: str
    mobile_phone: str
    preferred_language: str
    object: Literal["AccountOwnerProfile"]


class Imap(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    username: str
    port: float
    host: str


class Smtp(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    username: str
    port: float
    host: str


class ConnectionParams65(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap: Imap
    smtp: Smtp


class ApiV1UsersMeGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["IMAP"]
    connection_params: ConnectionParams65
    object: Literal["AccountOwnerProfile"]


class ApiV1UsersMeGetResponse(
    RootModel[
        Union[
            ApiV1UsersMeGetResponse1,
            ApiV1UsersMeGetResponse2,
            ApiV1UsersMeGetResponse3,
            ApiV1UsersMeGetResponse4,
            ApiV1UsersMeGetResponse5,
            ApiV1UsersMeGetResponse6,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        ApiV1UsersMeGetResponse1,
        ApiV1UsersMeGetResponse2,
        ApiV1UsersMeGetResponse3,
        ApiV1UsersMeGetResponse4,
        ApiV1UsersMeGetResponse5,
        ApiV1UsersMeGetResponse6,
    ]


class Type193(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ConnectionParams66(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    imap_host: str
    imap_encryption: Optional[str] = None
    imap_port: float
    imap_user: str
    smtp_host: str
    smtp_port: float
    smtp_user: str


class ApiV1UsersMeGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type193
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type194(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersMeGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type194
    status: Literal[403]


class Type195(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersMeGetResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type195
    status: Literal[404]


class Type196(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersMeGetResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type196
    status: Literal[422]


class ApiV1UsersMeGetResponse11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/too_many_requests"]
    status: Literal[429]


class Type197(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersMeGetResponse12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type197
    status: Literal[500]


class ApiV1UsersMeGetResponse13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type198(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersMeGetResponse14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type198
    status: Literal[503]


class ApiV1UsersMeGetResponse15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Location(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the location. Use the <strong>Retrieve LinkedIn search parameters</strong> route with type LOCATION to find the right one : https://developer.unipile.com/reference/linkedincontroller_getsearchparameterslist",
    )
    postal_code: Optional[str] = Field(
        default=None, description="A 5 digits postal code.", max_length=5, min_length=5
    )


class Filter(str, Enum):
    ORIGINAL = "ORIGINAL"
    STUDIO = "STUDIO"
    SPOTLIGHT = "SPOTLIGHT"
    PRIME = "PRIME"
    CLASSIC = "CLASSIC"
    EDGE = "EDGE"
    LUMINATE = "LUMINATE"


class BottomLeft(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    x: float
    y: float


class BottomRight(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    x: float
    y: float


class TopLeft(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    x: float
    y: float


class TopRight(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    x: float
    y: float


class Layout(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    bottom_left: Optional[BottomLeft] = Field(default=None, alias="bottomLeft")
    bottom_right: Optional[BottomRight] = Field(default=None, alias="bottomRight")
    top_left: Optional[TopLeft] = Field(default=None, alias="topLeft")
    top_right: Optional[TopRight] = Field(default=None, alias="topRight")


class PictureSettings(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    filter: Optional[Filter] = None
    layout: Optional[Layout] = None
    contrast: Optional[float] = None
    vignette: Optional[float] = None
    saturation: Optional[float] = None
    brightness: Optional[float] = None


class Layout1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    bottom_left: Optional[BottomLeft] = Field(default=None, alias="bottomLeft")
    bottom_right: Optional[BottomRight] = Field(default=None, alias="bottomRight")
    top_left: Optional[TopLeft] = Field(default=None, alias="topLeft")
    top_right: Optional[TopRight] = Field(default=None, alias="topRight")


class CoverPictureSettings(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    filter: Optional[Filter] = None
    layout: Optional[Layout1] = None
    contrast: Optional[float] = None
    vignette: Optional[float] = None
    saturation: Optional[float] = None
    brightness: Optional[float] = None


class Presence(str, Enum):
    ON_SITE = "ON_SITE"
    HYBRID = "HYBRID"
    REMOTE = "REMOTE"


class StartDate(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    month: float
    year: float


class EndDate(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    month: float
    year: float


class Seniority(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_date: StartDate
    end_date: Optional[EndDate] = None


class SourceOfHire(str, Enum):
    INDEED = "INDEED"
    LINKEDIN = "LINKEDIN"
    COMPANY_WEBSITE = "COMPANY_WEBSITE"
    OTHER_JOB_SITES = "OTHER_JOB_SITES"
    REFERRAL = "REFERRAL"
    CONTACTED_BY_RECRUITER = "CONTACTED_BY_RECRUITER"
    STAFFING_AGENCY = "STAFFING_AGENCY"
    OTHER = "OTHER"


class Attachment6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["link"]
    title: str
    description: Optional[str] = None
    url: str
    thumbnail: Optional[bytes] = Field(
        default=None,
        description="A replacement image if the default thumbnail is not satisfactory.",
    )


class Attachment7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["media"]
    title: str
    description: Optional[str] = None
    file: Optional[bytes] = Field(
        default=None, description="Should be an image or a document (pdf, ppt, doc)."
    )


class Experience(BaseModel):
    """
    Add or edit a professional experience.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    notify_network: Optional[bool] = None
    role: str
    employment_type: Optional[str] = Field(
        default=None,
        description="The ID of the type. Use the <strong>Retrieve LinkedIn search parameters</strong> route with type EMPLOYMENT_TYPE to find the right one : https://developer.unipile.com/reference/linkedincontroller_getsearchparameterslist.",
    )
    company: str
    location: Optional[str] = None
    presence: Optional[Presence] = None
    seniority: Optional[Seniority] = None
    description: Optional[str] = None
    source_of_hire: Optional[SourceOfHire] = None
    skills: Optional[list[str]] = None
    attachment: Optional[Union[Attachment6, Attachment7]] = None


class Seniority1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_date: StartDate
    end_date: Optional[EndDate] = None


class Attachment8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["link"]
    title: str
    description: Optional[str] = None
    url: str
    thumbnail: Optional[bytes] = Field(
        default=None,
        description="A replacement image if the default thumbnail is not satisfactory.",
    )


class Attachment9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["media"]
    title: str
    description: Optional[str] = None
    file: Optional[bytes] = Field(
        default=None, description="Should be an image or a document (pdf, ppt, doc)."
    )


class Experience1(BaseModel):
    """
    Add or edit a professional experience.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(..., description="This ID of the experience to be edited.")
    notify_network: Optional[bool] = None
    role: Optional[str] = None
    employment_type: Optional[str] = Field(
        default=None,
        description="The ID of the type. Use the <strong>Retrieve LinkedIn search parameters</strong> route with type EMPLOYMENT_TYPE to find the right one : https://developer.unipile.com/reference/linkedincontroller_getsearchparameterslist.",
    )
    company: Optional[str] = None
    location: Optional[str] = None
    presence: Optional[Presence] = None
    seniority: Optional[Seniority1] = None
    description: Optional[str] = None
    source_of_hire: Optional[SourceOfHire] = None
    skills: Optional[list[str]] = None
    attachment: Optional[Union[Attachment8, Attachment9]] = None


class Attachment10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["link"]
    title: str
    description: Optional[str] = None
    url: str
    thumbnail: Optional[bytes] = Field(
        default=None,
        description="A replacement image if the default thumbnail is not satisfactory.",
    )


class Attachment11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["media"]
    title: str
    description: Optional[str] = None
    file: Optional[bytes] = Field(
        default=None, description="Should be an image or a document (pdf, ppt, doc)."
    )


class Education(BaseModel):
    """
    Add or edit an education.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    notify_network: Optional[bool] = None
    school: str
    degree: Optional[str] = None
    grade: Optional[str] = None
    field_of_study: Optional[str] = None
    activities: Optional[str] = None
    description: Optional[str] = None
    start_date: Optional[StartDate] = None
    end_date: Optional[EndDate] = None
    skills: Optional[list[str]] = None
    attachment: Optional[Union[Attachment10, Attachment11]] = None


class Seniority2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start_date: StartDate
    end_date: Optional[EndDate] = None


class Attachment12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["link"]
    title: str
    description: Optional[str] = None
    url: str
    thumbnail: Optional[bytes] = Field(
        default=None,
        description="A replacement image if the default thumbnail is not satisfactory.",
    )


class Attachment13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["media"]
    title: str
    description: Optional[str] = None
    file: Optional[bytes] = Field(
        default=None, description="Should be an image or a document (pdf, ppt, doc)."
    )


class Education1(BaseModel):
    """
    Add or edit an education.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(..., description="This ID of the experience to be edited.")
    notify_network: Optional[bool] = None
    role: Optional[str] = None
    employment_type: Optional[str] = Field(
        default=None,
        description="The ID of the type. Use the <strong>Retrieve LinkedIn search parameters</strong> route with type EMPLOYMENT_TYPE to find the right one : https://developer.unipile.com/reference/linkedincontroller_getsearchparameterslist.",
    )
    company: Optional[str] = None
    location: Optional[str] = None
    presence: Optional[Presence] = None
    seniority: Optional[Seniority2] = None
    description: Optional[str] = None
    source_of_hire: Optional[SourceOfHire] = None
    skills: Optional[list[str]] = None
    attachment: Optional[Union[Attachment12, Attachment13]] = None


class ApiV1UsersMeEditPatchRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Literal["LINKEDIN"]
    account_id: str = Field(
        ..., description="An Unipile account id.", min_length=1, title="AccountIdParam"
    )
    location: Optional[Location] = None
    headline: Optional[str] = Field(
        default=None, description="The subtitle of your profile."
    )
    summary: Optional[str] = Field(
        default=None, description="The ABOUT section of your profile."
    )
    picture: Optional[bytes] = None
    picture_settings: Optional[PictureSettings] = None
    cover_picture: Optional[bytes] = None
    cover_picture_settings: Optional[CoverPictureSettings] = None
    experience: Optional[Union[Experience, Experience1]] = Field(
        default=None, description="Add or edit a professional experience."
    )
    education: Optional[Union[Education, Education1]] = Field(
        default=None, description="Add or edit an education."
    )
    skills: Optional[list[str]] = None
    skills_follow: Optional[bool] = None


class ApiV1UsersMeEditPatchResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ProfileEdited"]


class Type199(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersMeEditPatchResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type199
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type200(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersMeEditPatchResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type200
    status: Literal[403]


class Type201(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersMeEditPatchResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type201
    status: Literal[404]


class Type202(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersMeEditPatchResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type202
    status: Literal[422]


class ApiV1UsersMeEditPatchResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/too_many_requests"]
    status: Literal[429]


class Type203(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersMeEditPatchResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type203
    status: Literal[500]


class ApiV1UsersMeEditPatchResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type204(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersMeEditPatchResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type204
    status: Literal[503]


class ApiV1UsersMeEditPatchResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["UserRelation"]
    first_name: str
    last_name: str
    headline: str
    public_identifier: str
    public_profile_url: str
    created_at: float
    member_id: str
    member_urn: str
    connection_urn: str
    profile_picture_url: Optional[str] = None


class ApiV1UsersRelationsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["UserRelationsList"]
    items: list[Item10]
    cursor: Any


class Type205(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersRelationsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type205
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type206(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersRelationsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type206
    status: Literal[403]


class Type207(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersRelationsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type207
    status: Literal[404]


class Type208(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersRelationsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type208
    status: Literal[500]


class ApiV1UsersRelationsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type209(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersRelationsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type209
    status: Literal[503]


class ApiV1UsersRelationsGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["UserFollower"]
    id: str
    urn: str
    name: str
    headline: str
    profile_url: str
    profile_picture_url: Union[str, Any]
    profile_picture_url_large: Union[str, Any]


class ApiV1UsersFollowersGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["UserFollowersList"]
    items: list[Item11]
    cursor: Any


class Type210(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersFollowersGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type210
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type211(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersFollowersGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type211
    status: Literal[403]


class Type212(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersFollowersGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type212
    status: Literal[404]


class Type213(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersFollowersGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type213
    status: Literal[500]


class ApiV1UsersFollowersGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type214(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersFollowersGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type214
    status: Literal[503]


class ApiV1UsersFollowersGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class LinkedinSections(str, Enum):
    """
    A string with a section name.
    """

    EXPERIENCE = "experience"
    EDUCATION = "education"
    LANGUAGES = "languages"
    SKILLS = "skills"
    CERTIFICATIONS = "certifications"
    ABOUT = "about"
    VOLUNTEERING_EXPERIENCE = "volunteering_experience"
    PROJECTS = "projects"


class LinkedinSection(str, Enum):
    """
    A string with a section name.
    """

    EXPERIENCE = "experience"
    EDUCATION = "education"
    LANGUAGES = "languages"
    SKILLS = "skills"
    CERTIFICATIONS = "certifications"
    ABOUT = "about"
    VOLUNTEERING_EXPERIENCE = "volunteering_experience"
    PROJECTS = "projects"


class LinkedinApi(str, Enum):
    RECRUITER = "recruiter"
    SALES_NAVIGATOR = "sales_navigator"


class Social(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: str
    name: str


class ContactInfo3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    emails: Optional[list[str]] = None
    phones: Optional[list[str]] = None
    adresses: Optional[list[str]] = None
    socials: Optional[list[Social]] = None


class Birthdate(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    month: float
    day: float


class PrimaryLocale(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    country: str
    language: str


class Invitation(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Union[Literal["SENT"], Literal["RECEIVED"]]
    status: Union[Literal["PENDING"], Literal["IGNORED"], Literal["WITHDRAWN"]]


class WorkExperienceItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    position: str
    company_id: Optional[str] = None
    company: str
    location: Optional[str] = None
    description: Optional[str] = None
    skills: list[str]
    current: Optional[bool] = None
    status: Optional[str] = None
    start: Union[str, Any]
    end: Union[str, Any]


class VolunteeringExperienceItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    company: str
    description: str
    role: str
    cause: str
    start: Union[str, Any]
    end: Union[str, Any]


class EducationItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    degree: Optional[str] = None
    school: str
    field_of_study: Optional[str] = None
    start: Union[str, Any]
    end: Union[str, Any]


class Skill(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    endorsement_count: float
    endorsement_id: Union[float, Any]
    insights: list[str]
    endorsed: bool


class Language(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    proficiency: Optional[str] = None


class Certification(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    organization: str
    url: Optional[str] = None


class Project(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    name: str
    description: str
    skills: list[str]
    start: Union[str, Any]
    end: Union[str, Any]


class ApiV1UsersIdentifierGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    provider_id: str
    public_identifier: Union[str, Any]
    first_name: Union[str, Any]
    last_name: Union[str, Any]
    headline: str
    summary: Optional[str] = None
    contact_info: Optional[ContactInfo3] = None
    birthdate: Optional[Birthdate] = None
    primary_locale: Optional[PrimaryLocale] = None
    location: Optional[str] = None
    websites: list[str]
    profile_picture_url: Optional[str] = None
    profile_picture_url_large: Optional[str] = None
    background_picture_url: Optional[str] = None
    hashtags: Optional[list[str]] = None
    can_send_inmail: Optional[bool] = None
    is_open_profile: Optional[bool] = None
    is_premium: Optional[bool] = None
    is_influencer: Optional[bool] = None
    is_creator: Optional[bool] = None
    is_hiring: Optional[bool] = None
    is_open_to_work: Optional[bool] = None
    is_saved_lead: Optional[bool] = None
    is_crm_imported: Optional[bool] = None
    is_relationship: Optional[bool] = None
    is_self: Optional[bool] = None
    invitation: Optional[Invitation] = None
    work_experience: Optional[list[WorkExperienceItem]] = None
    volunteering_experience: Optional[list[VolunteeringExperienceItem]] = None
    education: Optional[list[EducationItem]] = None
    skills: Optional[list[Skill]] = None
    languages: Optional[list[Language]] = None
    certifications: Optional[list[Certification]] = None
    projects: Optional[list[Project]] = None
    follower_count: Optional[float] = None
    connections_count: Optional[float] = None
    shared_connections_count: Optional[float] = None
    network_distance: Optional[
        Union[
            Literal["FIRST_DEGREE"],
            Literal["SECOND_DEGREE"],
            Literal["THIRD_DEGREE"],
            Literal["OUT_OF_NETWORK"],
        ]
    ] = None
    public_profile_url: Optional[str] = None
    object: Literal["UserProfile"]


class ApiV1UsersIdentifierGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["WHATSAPP"]
    id: str
    object: Literal["UserProfile"]


class ApiV1UsersIdentifierGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["INSTAGRAM"]
    pk: float
    username: str
    full_name: str
    profile_pic_url: str
    biography: str
    follower_count: float
    following_count: float
    is_verified: bool
    is_business: bool
    is_private: bool
    object: Literal["UserProfile"]


class ApiV1UsersIdentifierGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["TELEGRAM"]
    provider_id: str
    self: Optional[Union[bool, Any]] = None
    contact: Optional[Union[bool, Any]] = None
    mutual_contact: Optional[Union[bool, Any]] = None
    deleted: Optional[Union[bool, Any]] = None
    bot: Optional[Union[bool, Any]] = None
    verified: Optional[Union[bool, Any]] = None
    restricted: Optional[Union[bool, Any]] = None
    fake: Optional[Union[bool, Any]] = None
    premium: Optional[Union[bool, Any]] = None
    close_friend: Optional[Union[bool, Any]] = None
    first_name: Optional[Union[str, Any]] = None
    last_name: Optional[Union[str, Any]] = None
    username: Optional[Union[str, Any]] = None
    phone: Optional[Union[str, Any]] = None
    profile_picture_url: str
    status: Optional[Union[Status2, Any]] = None
    restriction_reason: Optional[Union[list[RestrictionReasonItem], Any]] = None
    lang_code: Optional[Union[str, Any]] = None
    object: Literal["UserProfile"]


class Entities1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    description: Description


class ApiV1UsersIdentifierGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["TWITTER"]
    id: str
    name: str
    screen_name: str
    location: str
    description: Union[Any, str]
    url: Union[Any, str]
    entities: Entities1
    protected: bool
    verified: bool
    followers_count: float
    friends_count: float
    listed_count: float
    favourites_count: float
    statuses_count: float
    created_at: str
    profile_banner_url: Optional[Union[str, Any]] = None
    profile_image_url_https: str
    default_profile: bool
    default_profile_image: bool
    withheld_in_countries: list[str]
    followed_by: Optional[Union[Any, bool]] = None
    following: Optional[Union[Any, bool]] = None
    follow_request_sent: Optional[Union[Any, bool]] = None
    has_extended_profile: Optional[Union[Any, bool]] = None
    notifications: Optional[Union[Any, bool]] = None
    advertiser_account_type: Optional[Union[Any, str]] = None
    business_profile_state: Optional[Union[Any, str]] = None
    require_some_consent: Optional[Union[Any, bool]] = None
    object: Literal["UserProfile"]


class ApiV1UsersIdentifierGetResponse(
    RootModel[
        Union[
            ApiV1UsersIdentifierGetResponse1,
            ApiV1UsersIdentifierGetResponse2,
            ApiV1UsersIdentifierGetResponse3,
            ApiV1UsersIdentifierGetResponse4,
            ApiV1UsersIdentifierGetResponse5,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        ApiV1UsersIdentifierGetResponse1,
        ApiV1UsersIdentifierGetResponse2,
        ApiV1UsersIdentifierGetResponse3,
        ApiV1UsersIdentifierGetResponse4,
        ApiV1UsersIdentifierGetResponse5,
    ]


class Type215(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersIdentifierGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type215
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type216(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersIdentifierGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type216
    status: Literal[403]


class Type217(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersIdentifierGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type217
    status: Literal[404]


class Type218(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersIdentifierGetResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type218
    status: Literal[422]


class ApiV1UsersIdentifierGetResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/too_many_requests"]
    status: Literal[429]


class Type219(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersIdentifierGetResponse11(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type219
    status: Literal[500]


class ApiV1UsersIdentifierGetResponse12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type220(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersIdentifierGetResponse13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type220
    status: Literal[503]


class ApiV1UsersIdentifierGetResponse14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1UsersInvitePostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider_id: str = Field(
        ..., description="The id of the user to add. It has to be the provider’s id."
    )
    account_id: str = Field(
        ..., description="The id of the account where the user will be added."
    )
    user_email: Optional[str] = Field(
        default=None,
        description="The email address of the user when it's required (Linkedin specific).",
    )
    message: Optional[str] = Field(
        default=None,
        description="An optional message to go with the invitation (max 300 chars).",
        max_length=300,
    )


class ApiV1UsersInvitePostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["UserInvitationSent"]
    invitation_id: str
    usage: Optional[float] = Field(
        default=None,
        description="A percentage of query usage based on the limit set by the provider. Triggers only on passing a new landing (50, 75, 90, 95).",
    )


class Type221(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1UsersInvitePostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type221
    status: Literal[400]


class Type222(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersInvitePostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type222
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type223(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersInvitePostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type223
    status: Literal[403]


class Type224(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersInvitePostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type224
    status: Literal[404]


class Type225(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersInvitePostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type225
    status: Literal[422]


class ApiV1UsersInvitePostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/too_many_requests"]
    status: Literal[429]


class Type226(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersInvitePostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type226
    status: Literal[500]


class ApiV1UsersInvitePostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/feature_not_implemented"]
    status: Literal[501]


class Type227(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersInvitePostResponse9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type227
    status: Literal[503]


class ApiV1UsersInvitePostResponse10(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Author(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    public_identifier: str
    name: str
    is_company: bool


class Permissions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    can_react: bool
    can_share: bool
    can_post_comments: bool


class RepostedBy(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    public_identifier: str
    name: str
    is_company: bool


class RepostContent(BaseModel):
    """
    The post shared in the current publication.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    date: str
    parsed_datetime: str
    author: Author
    text: str


class Attachments50(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments51(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments52(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments53(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments54(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Option(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    text: str
    win: bool
    votes_count: float


class Poll(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    total_votes_count: float
    question: str
    is_open: bool
    options: list[Option]


class Item12(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    social_id: str = Field(
        ...,
        description="A unique identifier to be used to add a comment or a reaction to the post.",
    )
    share_url: str
    title: Optional[str] = None
    text: str
    date: str
    parsed_datetime: str
    reaction_counter: float
    comment_counter: float
    repost_counter: float
    impressions_counter: float
    author: Author
    permissions: Permissions
    is_repost: bool
    repost_id: Optional[str] = Field(default=None, description="The republication ID.")
    reposted_by: Optional[RepostedBy] = None
    repost_content: Optional[RepostContent] = Field(
        default=None, description="The post shared in the current publication."
    )
    attachments: list[
        Union[Attachments50, Attachments51, Attachments52, Attachments53, Attachments54]
    ]
    poll: Optional[Poll] = None
    object: Literal["Post"]


class Paging(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    page_count: float


class ApiV1UsersIdentifierPostsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["PostList"]
    items: list[Item12]
    cursor: Union[str, Any]
    paging: Paging


class Type228(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersIdentifierPostsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type228
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type229(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersIdentifierPostsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type229
    status: Literal[403]


class Type230(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersIdentifierPostsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type230
    status: Literal[422]


class Type231(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersIdentifierPostsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type231
    status: Literal[500]


class Type232(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersIdentifierPostsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type232
    status: Literal[503]


class ApiV1UsersIdentifierPostsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class AuthorDetails(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Union[str, Any]
    headline: Union[str, Any]
    profile_url: Union[str, Any]
    network_distance: Union[
        Literal["FIRST_DEGREE"],
        Literal["SECOND_DEGREE"],
        Literal["THIRD_DEGREE"],
        Literal["OUT_OF_NETWORK"],
        Any,
    ]


class Item13(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Comment"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    post_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    author: Union[str, Any]
    author_details: AuthorDetails
    date: str
    text: str
    reaction_counter: float
    reply_counter: float


class ApiV1UsersIdentifierCommentsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["CommentList"]
    items: list[Item13]
    cursor: Union[str, Any]
    paging: Paging


class Type233(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersIdentifierCommentsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type233
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type234(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersIdentifierCommentsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type234
    status: Literal[403]


class Type235(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersIdentifierCommentsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type235
    status: Literal[422]


class Type236(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersIdentifierCommentsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type236
    status: Literal[500]


class Type237(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersIdentifierCommentsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type237
    status: Literal[503]


class ApiV1UsersIdentifierCommentsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Author2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[Literal["INDIVIDUAL"], Literal["COMPANY"]]
    name: Union[str, Any]
    headline: Union[str, Any]
    profile_url: Union[str, Any]
    network_distance: Optional[
        Union[
            Literal["FIRST_DEGREE"],
            Literal["SECOND_DEGREE"],
            Literal["THIRD_DEGREE"],
            Literal["OUT_OF_NETWORK"],
        ]
    ] = None


class Item14(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["PostReaction"]
    value: Union[
        Literal["LIKE"],
        Literal["PRAISE"],
        Literal["APPRECIATION"],
        Literal["EMPATHY"],
        Literal["INTEREST"],
        Literal["ENTERTAINMENT"],
    ]
    post_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    comment_id: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    author: Author2


class ApiV1UsersIdentifierReactionsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["PostReactionList"]
    items: list[Item14]
    cursor: Union[str, Any]
    paging: Paging


class Type238(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersIdentifierReactionsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type238
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type239(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersIdentifierReactionsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type239
    status: Literal[403]


class Type240(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1UsersIdentifierReactionsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type240
    status: Literal[422]


class Type241(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersIdentifierReactionsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type241
    status: Literal[500]


class Type242(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersIdentifierReactionsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type242
    status: Literal[503]


class ApiV1UsersIdentifierReactionsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1UsersInviteSentInvitationIdDeleteResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["InvitationCanceled"]


class Type243(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1UsersInviteSentInvitationIdDeleteResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type243
    status: Literal[400]


class Type244(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1UsersInviteSentInvitationIdDeleteResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type244
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type245(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1UsersInviteSentInvitationIdDeleteResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type245
    status: Literal[403]


class Type246(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1UsersInviteSentInvitationIdDeleteResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type246
    status: Literal[404]


class Type247(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1UsersInviteSentInvitationIdDeleteResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type247
    status: Literal[500]


class Type248(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1UsersInviteSentInvitationIdDeleteResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type248
    status: Literal[503]


class ApiV1UsersInviteSentInvitationIdDeleteResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item15(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["RecruiterHiringProject"]
    id: str
    name: str
    owner_name: str
    owner_id: str
    created_at: str


class ApiV1LinkedinProjectsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["RecruiterHiringProjectList"]
    items: list[Item15]
    cursor: Any


class Type249(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinProjectsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type249
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type250(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinProjectsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type250
    status: Literal[403]


class Type251(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinProjectsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type251
    status: Literal[404]


class Type252(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinProjectsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type252
    status: Literal[422]


class Type253(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinProjectsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type253
    status: Literal[500]


class Type254(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinProjectsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type254
    status: Literal[503]


class ApiV1LinkedinProjectsGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Messaging2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_enabled: bool
    id: Optional[str] = None
    entity_urn: Optional[str] = None


class ViewerPermissions(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    can_members_invite_to_follow: bool = Field(..., alias="canMembersInviteToFollow")
    can_read_content_suggestions: bool = Field(..., alias="canReadContentSuggestions")
    can_read_messages: bool = Field(..., alias="canReadMessages")
    can_update_organization_profile: bool = Field(
        ..., alias="canUpdateOrganizationProfile"
    )
    can_create_organic_share: bool = Field(..., alias="canCreateOrganicShare")
    can_read_admin_dashboard: bool = Field(..., alias="canReadAdminDashboard")
    can_read_organization_activity: bool = Field(
        ..., alias="canReadOrganizationActivity"
    )
    can_edit_curators: bool = Field(..., alias="canEditCurators")
    can_manage_organizational_page_follow: bool = Field(
        ..., alias="canManageOrganizationalPageFollow"
    )
    can_read_organization_follower_analytics: bool = Field(
        ..., alias="canReadOrganizationFollowerAnalytics"
    )
    can_invite_member_to_follow: bool = Field(..., alias="canInviteMemberToFollow")
    can_read_organization_leads_analytics: bool = Field(
        ..., alias="canReadOrganizationLeadsAnalytics"
    )
    can_edit_pending_administrators: bool = Field(
        ..., alias="canEditPendingAdministrators"
    )
    can_manage_messaging_access: bool = Field(..., alias="canManageMessagingAccess")
    can_see_employee_experience_as_member: bool = Field(
        ..., alias="canSeeEmployeeExperienceAsMember"
    )
    can_employees_invite_to_follow: bool = Field(
        ..., alias="canEmployeesInviteToFollow"
    )
    can_see_organization_administrative_page: bool = Field(
        ..., alias="canSeeOrganizationAdministrativePage"
    )


class Location1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    is_headquarter: bool
    country: str
    city: str
    postal_code: Optional[str] = Field(default=None, alias="postalCode")
    street: list[str]
    description: Optional[str] = None
    area: Optional[str] = None


class EmployeeCountRange(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    from_: float = Field(..., alias="from")
    to: float


class EmployeesCountGraphItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    date: str
    count: float


class GrowthGraphItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    month_range: float = Field(..., alias="monthRange")
    growth_percentage: float = Field(..., alias="growthPercentage")


class EmployeesCount(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    total_count: float = Field(..., alias="totalCount")
    average_tenure: str = Field(..., alias="averageTenure")
    employees_count_graph: list[EmployeesCountGraphItem] = Field(
        ..., alias="employeesCountGraph"
    )
    growth_graph: list[GrowthGraphItem] = Field(..., alias="growthGraph")


class Insights(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    employees_count: Optional[EmployeesCount] = Field(
        default=None, alias="employeesCount"
    )


class ApiV1LinkedinCompanyIdentifierGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["CompanyProfile"]
    id: str
    name: str
    description: str
    entity_urn: str
    public_identifier: str
    profile_url: str
    tagline: Optional[str] = None
    followers_count: Optional[float] = None
    is_following: Optional[bool] = None
    is_employee: Optional[bool] = None
    messaging: Messaging2
    default_locale: str
    claimed: bool
    viewer_permissions: ViewerPermissions
    organization_type: Union[
        Literal["PUBLIC_COMPANY"],
        Literal["EDUCATIONAL"],
        Literal["SELF_EMPLOYED"],
        Literal["GOVERNMENT_AGENCY"],
        Literal["NON_PROFIT"],
        Literal["SELF_OWNED"],
        Literal["PRIVATELY_HELD"],
        Literal["PARTNERSHIP"],
        Any,
    ]
    locations: list[Location1]
    logo: Optional[str] = None
    localized_description: Optional[list[dict[str, Any]]] = None
    localized_name: Optional[list[dict[str, Any]]] = None
    localized_tagline: Optional[list[dict[str, Any]]] = None
    industry: Optional[list[str]] = None
    activities: Optional[list[str]] = None
    employee_count: Optional[float] = None
    employee_count_range: Optional[EmployeeCountRange] = None
    website: Optional[str] = None
    foundation_date: Optional[str] = None
    phone: Optional[str] = None
    insights: Optional[Insights] = None


class Type255(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinCompanyIdentifierGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type255
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type256(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinCompanyIdentifierGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type256
    status: Literal[403]


class Type257(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinCompanyIdentifierGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type257
    status: Literal[404]


class Type258(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinCompanyIdentifierGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type258
    status: Literal[422]


class Type259(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinCompanyIdentifierGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type259
    status: Literal[500]


class Type260(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinCompanyIdentifierGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type260
    status: Literal[503]


class ApiV1LinkedinCompanyIdentifierGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Method(str, Enum):
    """
    The method to be used for the request to be performed. Default is GET.
    """

    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    PATCH = "PATCH"
    DELETE = "DELETE"


class ApiV1LinkedinPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    request_url: str = Field(
        ...,
        description="An url pointing to some Linkedin API feature",
        pattern="^https://www.linkedin.com/.*$",
        title="LinkedinRequestUrl",
    )
    method: Optional[Method] = Field(
        default=None,
        description="The method to be used for the request to be performed. Default is GET.",
    )
    headers: Optional[dict[str, Any]] = Field(
        default=None, description="A headers object to be added to requests if needed."
    )
    body: Optional[dict[str, Any]] = Field(
        default=None, description="A body object to be passed for POST requests."
    )
    query_params: Optional[dict[str, Any]] = Field(
        default=None, description="A query parameters object."
    )
    encoding: bool = Field(
        default=True,
        description="Whether the query params or the body (in case of x-www-form-urlencoded content) should be encoded on the go.",
    )


class ApiV1LinkedinPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinRawData"]
    data: Any


class Type261(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1LinkedinPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type261
    status: Literal[400]


class Type262(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type262
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type263(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type263
    status: Literal[403]


class Type264(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type264
    status: Literal[404]


class Type265(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type265
    status: Literal[422]


class Type266(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type266
    status: Literal[500]


class Type267(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type267
    status: Literal[503]


class ApiV1LinkedinPostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1LinkedinInmailBalanceGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinInmailBalance"]
    premium: Union[float, Any]
    recruiter: Union[float, Any]
    sales_navigator: Union[float, Any]


class Type268(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinInmailBalanceGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type268
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type269(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinInmailBalanceGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type269
    status: Literal[403]


class Type270(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinInmailBalanceGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type270
    status: Literal[404]


class Type271(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinInmailBalanceGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type271
    status: Literal[422]


class Type272(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinInmailBalanceGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type272
    status: Literal[500]


class Type273(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinInmailBalanceGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type273
    status: Literal[503]


class ApiV1LinkedinInmailBalanceGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Type274(str, Enum):
    LOCATION = "LOCATION"
    PEOPLE = "PEOPLE"
    COMPANY = "COMPANY"
    SCHOOL = "SCHOOL"
    INDUSTRY = "INDUSTRY"
    SERVICE = "SERVICE"
    JOB_FUNCTION = "JOB_FUNCTION"
    JOB_TITLE = "JOB_TITLE"
    EMPLOYMENT_TYPE = "EMPLOYMENT_TYPE"
    SKILL = "SKILL"


class Type275(str, Enum):
    GROUPS = "GROUPS"
    DEPARTMENT = "DEPARTMENT"
    PERSONA = "PERSONA"
    ACCOUNT_LISTS = "ACCOUNT_LISTS"
    LEAD_LISTS = "LEAD_LISTS"
    TECHNOLOGIES = "TECHNOLOGIES"
    SAVED_ACCOUNTS = "SAVED_ACCOUNTS"
    SAVED_SEARCHES = "SAVED_SEARCHES"
    RECENT_SEARCHES = "RECENT_SEARCHES"


class Type276(str, Enum):
    GROUPS = "GROUPS"
    DEPARTMENT = "DEPARTMENT"
    HIRING_PROJECTS = "HIRING_PROJECTS"
    SAVED_SEARCHES = "SAVED_SEARCHES"
    SAVED_FILTERS = "SAVED_FILTERS"


class Item16(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinSearchParameter"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    title: str
    additional_data: Optional[dict[str, Any]] = None


class ApiV1LinkedinSearchParametersGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinSearchParametersList"]
    items: list[Item16]
    paging: Paging


class Type277(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1LinkedinSearchParametersGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type277
    status: Literal[400]


class Type278(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinSearchParametersGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type278
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type279(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinSearchParametersGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type279
    status: Literal[403]


class Type280(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinSearchParametersGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type280
    status: Literal[404]


class Type281(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinSearchParametersGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type281
    status: Literal[500]


class Type282(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinSearchParametersGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type282
    status: Literal[503]


class ApiV1LinkedinSearchParametersGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class NetworkDistanceEnum(float, Enum):
    NUMBER_1 = 1
    NUMBER_2 = 2
    NUMBER_3 = 3


class OpenToEnum(str, Enum):
    PRO_BONO = "proBono"
    BOARD_MEMBER = "boardMember"


class AdvancedKeywords(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    first_name: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS / FIRST NAME."
    )
    last_name: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS / LAST NAME."
    )
    title: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS / TITLE."
    )
    company: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS / LAST NAME."
    )
    school: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS / LAST NAME."
    )


class LinkedinSearchPayload(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["people"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    location: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : LOCATIONS.",
        min_length=1,
        pattern="^\\d+$",
    )
    profile_language: Optional[list[str]] = Field(
        default=None,
        description="ISO 639-1 language code.\nLinkedin native filter : PROFILE LANGUAGE.",
        max_length=2,
        min_length=2,
    )
    network_distance: Optional[list[NetworkDistanceEnum]] = Field(
        default=None,
        description="First, second or third+ degree.\nLinkedin native filter : CONNECTIONS.",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : CURRENT COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    past_company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : PAST COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    school: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.\nLinkedin native filter : SCHOOL.",
        min_length=1,
        pattern="^\\d+$",
    )
    service: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SERVICE on the List search parameters route to find out the right ID.\nLinkedin native filter : SERVICE CATEGORIES.",
        min_length=1,
        pattern="^\\d+$",
    )
    connections_of: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : CONNECTIONS OF.",
        min_length=1,
        pattern="^.+$",
    )
    followers_of: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : FOLLOWERS OF.",
        min_length=1,
        pattern="^.+$",
    )
    open_to: Optional[list[OpenToEnum]] = Field(
        default=None, description="Linkedin native filter : OPEN TO."
    )
    advanced_keywords: Optional[AdvancedKeywords] = None


class Min(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class HeadcountItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min] = None
    max: Optional[Max] = None


class ApiV1LinkedinSearchPostRequest2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["companies"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    location: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : LOCATIONS.",
        min_length=1,
        pattern="^\\d+$",
    )
    has_job_offers: Optional[bool] = Field(
        default=None, description="Linkedin native filter : JOB LISTINGS ON LINKEDIN."
    )
    headcount: Optional[list[HeadcountItem]] = Field(
        default=None, description="Linkedin native filter : COMPANY SIZE."
    )
    network_distance: Optional[list[NetworkDistanceEnum]] = Field(
        default=None,
        description="First, second or third+ degree.\nLinkedin native filter : CONNECTIONS.",
    )


class SortBy(str, Enum):
    """
    Default value is relevance.
    Linkedin native filter : SORT BY.
    """

    RELEVANCE = "relevance"
    DATE = "date"


class DatePosted(str, Enum):
    """
    Linkedin native filter : DATE POSTED.
    """

    PAST_DAY = "past_day"
    PAST_WEEK = "past_week"
    PAST_MONTH = "past_month"


class ContentType(str, Enum):
    """
    Linkedin native filter : CONTENT TYPE.
    """

    VIDEOS = "videos"
    IMAGES = "images"
    LIVE_VIDEOS = "live_videos"
    COLLABORATIVE_ARTICLES = "collaborative_articles"
    DOCUMENTS = "documents"


class PostedBy(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    member: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : FROM MEMBER.",
        min_length=1,
        pattern="^.+$",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : FROM COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    me: Optional[bool] = Field(
        default=None, description="Linkedin native filter : POSTED BY [ME]."
    )
    first_connections: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : POSTED BY [1ST CONNECTIONS].",
    )
    people_you_follow: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : POSTED BY [PEOPLE YOU FOLLOW].",
    )


class Mentioning(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    member: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : MENTIONING MEMBER.",
        min_length=1,
        pattern="^.+$",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : MENTIONING COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )


class Author3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : AUTHOR INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : AUTHOR COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : AUTHOR KEYWORDS."
    )


class ApiV1LinkedinSearchPostRequest3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["posts"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    sort_by: Optional[SortBy] = Field(
        default=None,
        description="Default value is relevance.\nLinkedin native filter : SORT BY.",
    )
    date_posted: Optional[DatePosted] = Field(
        default=None, description="Linkedin native filter : DATE POSTED."
    )
    content_type: Optional[ContentType] = Field(
        default=None, description="Linkedin native filter : CONTENT TYPE."
    )
    posted_by: Optional[PostedBy] = None
    mentioning: Optional[Mentioning] = None
    author: Optional[Author3] = None


class SeniorityEnum(str, Enum):
    EXECUTIVE = "executive"
    DIRECTOR = "director"
    MID_SENIOR = "mid_senior"
    ASSOCIATE = "associate"
    ENTRY = "entry"
    INTERN = "intern"


class JobTypeEnum(str, Enum):
    FULL_TIME = "full_time"
    PART_TIME = "part_time"
    CONTRACT = "contract"
    TEMPORARY = "temporary"
    VOLUNTEER = "volunteer"
    INTERNSHIP = "internship"
    OTHER = "other"


class PresenceEnum(str, Enum):
    ON_SITE = "on_site"
    HYBRID = "hybrid"
    REMOTE = "remote"


class Benefit(str, Enum):
    MEDICAL_INSURANCE = "medical_insurance"
    VISION_INSURANCE = "vision_insurance"
    DENTAL_INSURANCE = "dental_insurance"
    DISABILITY_INSURANCE = "disability_insurance"
    FIELD_401_K_ = "401(k)"
    PENSION_PLAN = "pension_plan"
    PAID_MATERNITY_LEAVE = "paid_maternity_leave"
    PAID_PATERNITY_LEAVE = "paid_paternity_leave"
    COMMUTER_BENEFITS = "commuter_benefits"
    STUDENT_LOAN_ASSISTANCE = "student_loan_assistance"
    TUITION_ASSISTANCE = "tuition_assistance"


class Commitment(str, Enum):
    CAREER_GROWTH_AND_LEARNING = "career_growth_and_learning"
    DIVERSITY_EQUITY_AND_INCLUSION = "diversity_equity_and_inclusion"
    ENVIRONMENTAL_SUSTAINABILITY = "environmental_sustainability"
    SOCIAL_IMPACT = "social_impact"
    WORK_LIFE_BALANCE = "work_life_balance"


class ApiV1LinkedinSearchPostRequest4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["jobs"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    sort_by: Optional[SortBy] = Field(
        default=None,
        description="Default value is relevance.\nLinkedin native filter : SORT BY.",
    )
    date_posted: Optional[float] = Field(
        default=None,
        description="The timespan in days since today for the filter to be applied.\nLinkedin native filter : DATE POSTED.",
    )
    region: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : GLOBAL LOCATION.",
        pattern="^\\d+$",
    )
    location: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : LOCATION.",
        min_length=1,
        pattern="^\\d+$",
    )
    location_within_area: Optional[float] = Field(
        default=None,
        description="The search zone around the location in miles.\nLinkedin native filter : DISTANCE.",
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    seniority: Optional[list[SeniorityEnum]] = Field(
        default=None, description="Linkedin native filter : EXPERIENCE LEVEL."
    )
    function: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_FUNCTION on the List search parameters route to find out the right ID.\nLinkedin native filter : JOB FUNCTION.",
        min_length=1,
        pattern="^[a-z]+$",
    )
    role: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.\nLinkedin native filter : TITLE.",
        min_length=1,
        pattern="^\\d+$",
    )
    job_type: Optional[list[JobTypeEnum]] = Field(
        default=None, description="Linkedin native filter : JOB TYPE."
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    presence: Optional[list[PresenceEnum]] = None
    easy_apply: Optional[bool] = Field(
        default=None, description="Linkedin native filter : EASY APPLY."
    )
    has_verifications: Optional[bool] = Field(
        default=None, description="Linkedin native filter : HAS VERIFICATIONS."
    )
    under_10_applicants: Optional[bool] = Field(
        default=None, description="Linkedin native filter : UNDER 10 APPLICANTS."
    )
    in_your_network: Optional[bool] = Field(
        default=None, description="Linkedin native filter : IN YOUR NETWORK."
    )
    fair_chance_employer: Optional[bool] = Field(
        default=None, description="Linkedin native filter : FAIR CHANCE EMPLOYER."
    )
    benefits: Optional[list[Benefit]] = Field(
        default=None, description="Linkedin native filter : BENEFITS."
    )
    commitments: Optional[list[Commitment]] = Field(
        default=None, description="Linkedin native filter : COMMITMENTS."
    )


class Location2(BaseModel):
    """
    Linkedin native filter : GEOGRAPHY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Industry(BaseModel):
    """
    Linkedin native filter : INDUSTRY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min1(float, Enum):
    NUMBER_0 = 0
    NUMBER_1 = 1
    NUMBER_3 = 3
    NUMBER_6 = 6
    NUMBER_10 = 10


class Max1(float, Enum):
    NUMBER_1 = 1
    NUMBER_2 = 2
    NUMBER_5 = 5
    NUMBER_10 = 10


class TenureItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min1] = None
    max: Optional[Max1] = None


class School(BaseModel):
    """
    Linkedin native filter : SCHOOL.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Company(BaseModel):
    """
    Linkedin native filter : CURRENT COMPANY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min2(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max2(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class CompanyHeadcountItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min2] = None
    max: Optional[Max2] = None


class CompanyTypeEnum(str, Enum):
    PUBLIC_COMPANY = "public_company"
    PRIVATELY_HELD = "privately_held"
    NON_PROFIT = "non_profit"
    EDUCATIONAL_INSTITUTION = "educational_institution"
    PARTNERSHIP = "partnership"
    SELF_EMPLOYED = "self_employed"
    SELF_OWNED = "self_owned"
    GOVERNMENT_AGENCY = "government_agency"


class CompanyLocation(BaseModel):
    """
    Linkedin native filter : COMPANY HEADQUARTERS LOCATION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min3(float, Enum):
    NUMBER_0 = 0
    NUMBER_1 = 1
    NUMBER_3 = 3
    NUMBER_6 = 6
    NUMBER_10 = 10


class Max3(float, Enum):
    NUMBER_1 = 1
    NUMBER_2 = 2
    NUMBER_5 = 5
    NUMBER_10 = 10


class TenureAtCompanyItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min3] = None
    max: Optional[Max3] = None


class PastCompany(BaseModel):
    """
    Linkedin native filter : PAST COMPANY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Function(BaseModel):
    """
    Linkedin native filter : FUNCTION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Role(BaseModel):
    """
    Linkedin native filter : CURRENT JOB TITLE.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class TenureAtRoleItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min3] = None
    max: Optional[Max3] = None


class IncludeEnum(str, Enum):
    OWNER_PARTNER = "owner/partner"
    CXO = "cxo"
    VICE_PRESIDENT = "vice_president"
    DIRECTOR = "director"
    EXPERIENCED_MANAGER = "experienced_manager"
    ENTRY_LEVEL_MANAGER = "entry_level_manager"
    STRATEGIC = "strategic"
    SENIOR = "senior"
    ENTRY_LEVEL = "entry_level"
    IN_TRAINING = "in_training"


class ExcludeEnum(str, Enum):
    OWNER_PARTNER = "owner/partner"
    CXO = "cxo"
    VICE_PRESIDENT = "vice_president"
    DIRECTOR = "director"
    EXPERIENCED_MANAGER = "experienced_manager"
    ENTRY_LEVEL_MANAGER = "entry_level_manager"
    STRATEGIC = "strategic"
    SENIOR = "senior"
    ENTRY_LEVEL = "entry_level"
    IN_TRAINING = "in_training"


class Seniority3(BaseModel):
    """
    Linkedin native filter : SENIORITY LEVEL.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[IncludeEnum]] = None
    exclude: Optional[list[ExcludeEnum]] = None


class PastRole(BaseModel):
    """
    Linkedin native filter : PAST JOB TITLE.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class NetworkDistance(float, Enum):
    NUMBER_1 = 1
    NUMBER_2 = 2
    NUMBER_3 = 3


class AccountLists(BaseModel):
    """
    Linkedin native filter : ACCOUNT LISTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )


class LeadLists(BaseModel):
    """
    Linkedin native filter : LEAD LISTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LEAD_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LEAD_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class ApiV1LinkedinSearchPostRequest5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["sales_navigator"]
    category: Literal["people"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    saved_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    recent_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type RECENT_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    location: Optional[Location2] = Field(
        default=None, description="Linkedin native filter : GEOGRAPHY."
    )
    industry: Optional[Industry] = Field(
        default=None, description="Linkedin native filter : INDUSTRY."
    )
    first_name: Optional[str] = Field(
        default=None, description="Linkedin native filter : FIRST NAME."
    )
    last_name: Optional[str] = Field(
        default=None, description="Linkedin native filter : LAST NAME."
    )
    tenure: Optional[list[TenureItem]] = Field(
        default=None, description="Linkedin native filter : YEARS OF EXPERIENCE."
    )
    groups: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type GROUPS on the List search parameters route to find out the right ID.\nLinkedin native filter : GROUPS.",
        min_length=1,
        pattern="^\\d+$",
    )
    school: Optional[School] = Field(
        default=None, description="Linkedin native filter : SCHOOL."
    )
    profile_language: Optional[list[str]] = Field(
        default=None,
        description="ISO 639-1 language code.\nLinkedin native filter : PROFILE LANGUAGE.",
        max_length=2,
        min_length=2,
    )
    company: Optional[Company] = Field(
        default=None, description="Linkedin native filter : CURRENT COMPANY."
    )
    company_headcount: Optional[list[CompanyHeadcountItem]] = Field(
        default=None, description="Linkedin native filter : COMPANY HEADCOUNT."
    )
    company_type: Optional[list[CompanyTypeEnum]] = Field(
        default=None, description="Linkedin native filter : COMPANY TYPE."
    )
    company_location: Optional[CompanyLocation] = Field(
        default=None,
        description="Linkedin native filter : COMPANY HEADQUARTERS LOCATION.",
    )
    tenure_at_company: Optional[list[TenureAtCompanyItem]] = Field(
        default=None, description="Linkedin native filter : YEARS IN CURRENT COMPANY."
    )
    past_company: Optional[PastCompany] = Field(
        default=None, description="Linkedin native filter : PAST COMPANY."
    )
    function: Optional[Function] = Field(
        default=None, description="Linkedin native filter : FUNCTION."
    )
    role: Optional[Role] = Field(
        default=None, description="Linkedin native filter : CURRENT JOB TITLE."
    )
    tenure_at_role: Optional[list[TenureAtRoleItem]] = Field(
        default=None, description="Linkedin native filter : YEARS IN CURRENT POSITION."
    )
    seniority: Optional[Seniority3] = Field(
        default=None, description="Linkedin native filter : SENIORITY LEVEL."
    )
    past_role: Optional[PastRole] = Field(
        default=None, description="Linkedin native filter : PAST JOB TITLE."
    )
    following_your_company: Optional[bool] = Field(
        default=None, description="Linkedin native filter : FOLLOWING YOUR COMPANY."
    )
    viewed_your_profile_recently: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : VIEWED YOUR PROFILE RECENTLY.",
    )
    network_distance: Optional[list[Union[NetworkDistance, Literal["GROUP"]]]] = Field(
        default=None,
        description="First, second, third+ degree or GROUP.\nLinkedin native filter : CONNECTION.",
    )
    connections_of: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : CONNECTIONS OF.",
        min_length=1,
        pattern="^.+$",
    )
    past_colleague: Optional[bool] = Field(
        default=None, description="Linkedin native filter : PAST COLLEAGUE."
    )
    shared_experiences: Optional[bool] = Field(
        default=None, description="Linkedin native filter : SHARED EXPERIENCES."
    )
    changed_jobs: Optional[bool] = Field(
        default=None, description="Linkedin native filter : CHANGED JOBS."
    )
    posted_on_linkedin: Optional[bool] = Field(
        default=None, description="Linkedin native filter : POSTED ON LINKEDIN."
    )
    mentionned_in_news: Optional[bool] = Field(
        default=None, description="Linkedin native filter : MENTIONNED IN NEWS."
    )
    persona: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PERSONA on the List search parameters route to find out the right ID.\nLinkedin native filter : PERSONA.",
        min_length=1,
        pattern="^\\d+$",
    )
    account_lists: Optional[AccountLists] = Field(
        default=None, description="Linkedin native filter : ACCOUNT LISTS."
    )
    lead_lists: Optional[LeadLists] = Field(
        default=None, description="Linkedin native filter : LEAD LISTS."
    )
    viewed_profile_recently: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : PEOPLE YOU INTERACTED WITH / VIEWED PROFILE.",
    )
    messaged_recently: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : PEOPLE YOU INTERACTED WITH / MESSAGED.",
    )
    include_saved_leads: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : SAVED LEADS AND ACCOUNTS / ALL MY SAVED LEADS.",
    )
    include_saved_accounts: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : SAVED LEADS AND ACCOUNTS / ALL MY SAVED ACCOUNTS.",
    )


class Industry1(BaseModel):
    """
    Linkedin native filter : INDUSTRY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Location3(BaseModel):
    """
    Linkedin native filter : HEADQUARTERS LOCATION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min5(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max5(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class HeadcountItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min5] = None
    max: Optional[Max5] = None


class HeadcountGrowth(BaseModel):
    """
    Linkedin native filter : COMPANY HEADCOUNT GROWTH.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: float
    max: float


class DepartmentHeadcount(BaseModel):
    """
    Linkedin native filter : DEPARTMENT HEADCOUNT.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    department: list[str] = Field(
        ...,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    min: float
    max: float


class DepartmentHeadcountGrowth(BaseModel):
    """
    Linkedin native filter : DEPARTMENT HEADCOUNT GROWTH.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    department: list[str] = Field(
        ...,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    min: float
    max: float


class Min6(float, Enum):
    NUMBER_0 = 0
    NUMBER_0_2 = 0.2
    NUMBER_1 = 1
    NUMBER_2_5 = 2.5
    NUMBER_5 = 5
    NUMBER_10 = 10
    NUMBER_20 = 20
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_1001 = 1001


class Max6(float, Enum):
    NUMBER_0 = 0
    NUMBER_0_2 = 0.2
    NUMBER_1 = 1
    NUMBER_2_5 = 2.5
    NUMBER_5 = 5
    NUMBER_10 = 10
    NUMBER_20 = 20
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_1001 = 1001


class AnnualRevenue(BaseModel):
    """
    Linkedin native filter : ANNUAL REVENUE. If you want to use the '1000+' value, please set the 'max' value field to 1001.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency: str = Field(
        ..., description="ISO 4217 currency code.", max_length=3, min_length=3
    )
    min: Min6
    max: Max6


class Min7(float, Enum):
    NUMBER_1 = 1
    NUMBER_51 = 51
    NUMBER_101 = 101
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001


class Max7(float, Enum):
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000


class FollowersCountItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min7] = None
    max: Optional[Max7] = None


class Min8(float, Enum):
    NUMBER_0 = 0
    NUMBER_51 = 51
    NUMBER_101 = 101
    NUMBER_251 = 251


class Max8(float, Enum):
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_250 = 250
    NUMBER_500 = 500


class FortuneItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min8] = None
    max: Optional[Max8] = None


class RecentActivity(str, Enum):
    SENIOR_LEADERSHIP_CHANGES = "senior_leadership_changes"
    FUNDING_EVENTS = "funding_events"


class AccountLists1(BaseModel):
    """
    Linkedin native filter : ACCOUNT LISTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )


class ApiV1LinkedinSearchPostRequest6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["sales_navigator"]
    category: Literal["companies"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    saved_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    recent_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type RECENT_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    industry: Optional[Industry1] = Field(
        default=None, description="Linkedin native filter : INDUSTRY."
    )
    location: Optional[Location3] = Field(
        default=None, description="Linkedin native filter : HEADQUARTERS LOCATION."
    )
    has_job_offers: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : JOB OPPORTUNITIES / HIRING ON LINKEDIN.",
    )
    headcount: Optional[list[HeadcountItem1]] = Field(
        default=None, description="Linkedin native filter : COMPANY HEADCOUNT."
    )
    headcount_growth: Optional[HeadcountGrowth] = Field(
        default=None, description="Linkedin native filter : COMPANY HEADCOUNT GROWTH."
    )
    department_headcount: Optional[DepartmentHeadcount] = Field(
        default=None, description="Linkedin native filter : DEPARTMENT HEADCOUNT."
    )
    department_headcount_growth: Optional[DepartmentHeadcountGrowth] = Field(
        default=None,
        description="Linkedin native filter : DEPARTMENT HEADCOUNT GROWTH.",
    )
    network_distance: Optional[list[NetworkDistanceEnum]] = Field(
        default=None,
        description="First, second or third+ degree.\nLinkedin native filter : CONNECTION.",
    )
    annual_revenue: Optional[AnnualRevenue] = Field(
        default=None,
        description="Linkedin native filter : ANNUAL REVENUE. If you want to use the '1000+' value, please set the 'max' value field to 1001.",
    )
    followers_count: Optional[list[FollowersCountItem]] = Field(
        default=None, description="Linkedin native filter : NUMBER OF FOLLOWERS."
    )
    fortune: Optional[list[FortuneItem]] = Field(
        default=None, description="Linkedin native filter : FORTUNE."
    )
    technologies: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type TECHNOLOGIES on the List search parameters route to find out the right ID.\nLinkedin native filter : TECHNOLOGIES USED.",
        min_length=1,
        pattern="^\\d+$",
    )
    recent_activities: Optional[list[RecentActivity]] = Field(
        default=None, description="Linkedin native filter : RECENT ACTIVITIES."
    )
    saved_accounts: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_ACCOUNTS on the List search parameters route to find out the right ID.\nLinkedin native filter : SAVED ACCOUNTS.",
        min_length=1,
        pattern="^.+$",
    )
    account_lists: Optional[AccountLists1] = Field(
        default=None, description="Linkedin native filter : ACCOUNT LISTS."
    )


class SavedSearch(BaseModel):
    """
    This parameter will override all others.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type SAVED_SEARCHES on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    project_id: str = Field(
        ...,
        description="The ID of the parameter. Use type SAVED_SEARCHES on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )


class Priority(str, Enum):
    CAN_HAVE = "CAN_HAVE"
    MUST_HAVE = "MUST_HAVE"
    DOESNT_HAVE = "DOESNT_HAVE"


class Scope(str, Enum):
    CURRENT = "CURRENT"
    OPEN_TO_RELOCATE_ONLY = "OPEN_TO_RELOCATE_ONLY"
    CURRENT_OR_OPEN_TO_RELOCATE = "CURRENT_OR_OPEN_TO_RELOCATE"


class LocationItem3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope] = None
    title: Optional[str] = Field(
        default=None,
        description="The title that came along with the ID in the List search parameters route response. Only necessary if the CURRENT_OR_OPEN_TO_RELOCATE value of the scope parameter is used.",
    )


class Industry2(BaseModel):
    """
    Linkedin native filter : INDUSTRIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Scope1(str, Enum):
    CURRENT_OR_PAST = "CURRENT_OR_PAST"
    CURRENT = "CURRENT"
    PAST = "PAST"
    PAST_NOT_CURRENT = "PAST_NOT_CURRENT"
    OPEN_TO_WORK = "OPEN_TO_WORK"


class Role1(BaseModel):
    """
    Linkedin native filter : JOB TITLES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    is_selection: bool = Field(
        ...,
        description="Linkedin job titles are either strict filters (only the people with that job) or selections (can include people with related jobs). A strict parameter cannot be used as a selection and vice versa. This information is provided on the List search parameters route results.",
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope1] = None


class Role2(BaseModel):
    """
    Linkedin native filter : JOB TITLES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    keywords: str = Field(
        ...,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope1] = None


class Skills(BaseModel):
    """
    Linkedin native filter : SKILLS AND ASSESSMENTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type SKILL on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class Skills1(BaseModel):
    """
    Linkedin native filter : SKILLS AND ASSESSMENTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    keywords: str = Field(
        ...,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    priority: Optional[Priority] = None


class Scope3(str, Enum):
    CURRENT_OR_PAST = "CURRENT_OR_PAST"
    CURRENT = "CURRENT"
    PAST = "PAST"
    PAST_NOT_CURRENT = "PAST_NOT_CURRENT"


class Company1(BaseModel):
    """
    Linkedin native filter : COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope3] = None


class Company2(BaseModel):
    """
    Linkedin native filter : COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    keywords: str = Field(
        ...,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope3] = None


class Min9(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max9(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class CompanyHeadcountItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min9] = None
    max: Optional[Max9] = None


class CurrentCompanyItem(BaseModel):
    """
    Linkedin native filter : CURRENT COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class PastCompanyItem1(BaseModel):
    """
    Linkedin native filter : PAST COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class SchoolItem1(BaseModel):
    """
    Linkedin native filter : SCHOOLS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class GraduationYear(BaseModel):
    """
    A range of years.
    Linkedin native filter : YEAR OF GRADUATION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[float] = Field(default=None, ge=1000.0, le=9999.0)
    max: Optional[float] = Field(default=None, ge=1000.0, le=9999.0)


class Tenure(BaseModel):
    """
    Linkedin native filter : YEARS OF EXPERIENCE.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[float] = None
    max: Optional[float] = None


class IncludeEnum1(str, Enum):
    OWNER = "owner"
    PARTNER = "partner"
    CXO = "cxo"
    VP = "vp"
    DIRECTOR = "director"
    MANAGER = "manager"
    SENIOR = "senior"
    ENTRY = "entry"
    TRAINING = "training"
    UNPAID = "unpaid"


class ExcludeEnum1(str, Enum):
    OWNER = "owner"
    PARTNER = "partner"
    CXO = "cxo"
    VP = "vp"
    DIRECTOR = "director"
    MANAGER = "manager"
    SENIOR = "senior"
    ENTRY = "entry"
    TRAINING = "training"
    UNPAID = "unpaid"


class Seniority4(BaseModel):
    """
    Linkedin native filter : SENIORITY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[IncludeEnum1]] = None
    exclude: Optional[list[ExcludeEnum1]] = None


class HidePreviouslyViewed(BaseModel):
    """
    Linkedin native filter : HIDE PREVIOUSLY VIEWED.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    timespan: float = Field(
        ...,
        description="The timespan in days since today for the filter to be applied.",
    )


class Min10(float, Enum):
    NUMBER_2 = 2
    NUMBER_8 = 8
    NUMBER_15 = 15
    NUMBER_31 = 31


class Max10(float, Enum):
    NUMBER_1 = 1
    NUMBER_7 = 7
    NUMBER_14 = 14
    NUMBER_30 = 30
    NUMBER_90 = 90


class RecentlyJoinedItem(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min10] = None
    max: Optional[Max10] = None


class HiringProjects(BaseModel):
    """
    Linkedin native filter : PROJECTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type HIRING_PROJECTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type HIRING_PROJECTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Id(str, Enum):
    MESSAGES = "messages"
    TAGS = "tags"
    NOTES = "notes"
    PROJECTS = "projects"
    RESUMES = "resumes"
    REVIEWS = "reviews"


class RecruitingActivityItem(BaseModel):
    """
    Linkedin native filter : RECRUITING ACTIVITY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Id
    priority: Optional[Priority] = None
    timespan: Optional[float] = Field(
        default=None,
        description="The timespan in days since today for the filter to be applied.",
    )


class ApiV1LinkedinSearchPostRequest7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["recruiter"]
    category: Literal["people"]
    keywords: Optional[str] = Field(
        default=None,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    saved_search: Optional[SavedSearch] = Field(
        default=None, description="This parameter will override all others."
    )
    saved_filter: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_FILTERS on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    location: Optional[list[LocationItem3]] = None
    location_within_area: Optional[float] = Field(
        default=None, description="The search zone around the location in miles."
    )
    industry: Optional[Industry2] = Field(
        default=None, description="Linkedin native filter : INDUSTRIES."
    )
    role: Optional[list[Union[Role1, Role2]]] = None
    skills: Optional[list[Union[Skills, Skills1]]] = None
    company: Optional[list[Union[Company1, Company2]]] = None
    company_headcount: Optional[list[CompanyHeadcountItem1]] = Field(
        default=None, description="Linkedin native filter : COMPANY SIZES."
    )
    current_company: Optional[list[CurrentCompanyItem]] = None
    past_company: Optional[list[PastCompanyItem1]] = None
    school: Optional[list[SchoolItem1]] = None
    groups: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type GROUPS on the List search parameters route to find out the right ID.\nLinkedin native filter : ALL GROUPS.",
        min_length=1,
        pattern="^\\d+$",
    )
    graduation_year: Optional[GraduationYear] = Field(
        default=None,
        description="A range of years.\nLinkedin native filter : YEAR OF GRADUATION.",
    )
    tenure: Optional[Tenure] = Field(
        default=None, description="Linkedin native filter : YEARS OF EXPERIENCE."
    )
    seniority: Optional[Seniority4] = Field(
        default=None, description="Linkedin native filter : SENIORITY."
    )
    function: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.\nLinkedin native filter : JOB FUNCTIONS.",
        min_length=1,
        pattern="^\\d+$",
    )
    network_distance: Optional[list[Union[NetworkDistance, Literal["GROUP"]]]] = Field(
        default=None,
        description="First, second, third+ degree or GROUP.\nLinkedin native filter : NETWORK RELATIONSHIPS.",
    )
    hide_previously_viewed: Optional[HidePreviouslyViewed] = Field(
        default=None, description="Linkedin native filter : HIDE PREVIOUSLY VIEWED."
    )
    profile_language: Optional[list[str]] = Field(
        default=None,
        description="ISO 639-1 language code.\nLinkedin native filter : PROFILE LANGUAGES.",
        max_length=2,
        min_length=2,
    )
    recently_joined: Optional[list[RecentlyJoinedItem]] = Field(
        default=None, description="Linkedin native filter : RECENTLY JOINED LINKEDIN."
    )
    first_name: Optional[list[str]] = Field(
        default=None, description="Linkedin native filter : FIRST NAMES.", min_length=1
    )
    last_name: Optional[list[str]] = Field(
        default=None, description="Linkedin native filter : LAST NAMES.", min_length=1
    )
    has_military_background: Optional[bool] = Field(
        default=None, description="Linkedin native filter : HAS US MILITARY BACKGROUND."
    )
    past_applicants: Optional[bool] = Field(
        default=None, description="Linkedin native filter : PAST APPLICANTS."
    )
    hiring_projects: Optional[HiringProjects] = Field(
        default=None, description="Linkedin native filter : PROJECTS."
    )
    recruiting_activity: Optional[list[RecruitingActivityItem]] = None
    notes: Optional[list[str]] = Field(
        default=None, description="Linkedin native filter : NOTES.", min_length=1
    )


class ApiV1LinkedinSearchPostRequest8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    url: str = Field(
        ...,
        description="Linkedin's public search URL. Setting this parameter will override the entire body.",
    )


class ApiV1LinkedinSearchPostRequest9(BaseModel):
    """
    In the case of a long cursor, you may want to set it in the body rather than in the query parameters.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    cursor: str = Field(
        ...,
        description="A cursor for pagination purposes. To get the next page of entries, you need to make a new request and fulfill this field with the cursor received in the preceding request. This process should be repeated until all entries have been retrieved.",
        min_length=1,
        title="CursorParam",
    )


class ApiV1LinkedinSearchPostRequest(
    RootModel[
        Union[
            LinkedinSearchPayload,
            ApiV1LinkedinSearchPostRequest2,
            ApiV1LinkedinSearchPostRequest3,
            ApiV1LinkedinSearchPostRequest4,
            ApiV1LinkedinSearchPostRequest5,
            ApiV1LinkedinSearchPostRequest6,
            ApiV1LinkedinSearchPostRequest7,
            ApiV1LinkedinSearchPostRequest8,
            ApiV1LinkedinSearchPostRequest9,
        ]
    ]
):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Union[
        LinkedinSearchPayload,
        ApiV1LinkedinSearchPostRequest2,
        ApiV1LinkedinSearchPostRequest3,
        ApiV1LinkedinSearchPostRequest4,
        ApiV1LinkedinSearchPostRequest5,
        ApiV1LinkedinSearchPostRequest6,
        ApiV1LinkedinSearchPostRequest7,
        ApiV1LinkedinSearchPostRequest8,
        ApiV1LinkedinSearchPostRequest9,
    ]


class LastOutreachActivity(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    type: Union[Literal["SEND_MESSAGE"], Literal["ACCEPT_INVITATION"]]
    performed_at: str


class TenureAtRole(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    years: Optional[float] = None
    months: Optional[float] = None


class TenureAtCompany(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    years: Optional[float] = None
    months: Optional[float] = None


class Start(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    year: Optional[float] = None
    month: Optional[float] = None


class End(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    year: Optional[float] = None
    month: Optional[float] = None


class CurrentPosition(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    company: str
    company_id: Union[str, Any]
    description: Union[str, Any]
    role: str
    location: Union[str, Any]
    tenure_at_role: Optional[TenureAtRole] = None
    tenure_at_company: Optional[TenureAtCompany] = None
    start: Optional[Start] = None
    end: Optional[End] = None


class EducationItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    degree: Union[str, Any]
    school: str
    school_id: Union[str, Any]
    start: Start
    end: Optional[End] = None


class WorkExperienceItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    company: str
    company_id: Union[str, Any]
    role: str
    industry: Union[str, Any]
    start: Start
    end: Optional[End] = None


class Items19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["SearchResult"]
    type: Literal["PEOPLE"]
    id: str
    public_identifier: Union[str, Any]
    public_profile_url: Union[str, Any]
    profile_url: Union[str, Any]
    profile_picture_url: Union[str, Any]
    profile_picture_url_large: Union[str, Any]
    member_urn: Union[str, Any]
    name: Union[str, Any]
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    network_distance: Union[
        Literal["SELF"],
        Literal["DISTANCE_1"],
        Literal["DISTANCE_2"],
        Literal["DISTANCE_3"],
        Literal["OUT_OF_NETWORK"],
    ]
    location: Union[str, Any]
    industry: Union[str, Any]
    keywords_match: Optional[str] = None
    headline: str
    connections_count: Optional[float] = None
    pending_invitation: Optional[bool] = None
    can_send_inmail: Optional[bool] = None
    recruiter_candidate_id: Optional[str] = None
    recruiter_pipeline_category: Optional[str] = None
    premium: Optional[bool] = None
    open_profile: Optional[bool] = None
    shared_connections_count: Optional[float] = None
    recent_posts_count: Optional[float] = None
    recently_hired: Optional[bool] = None
    mentioned_in_the_news: Optional[bool] = None
    last_outreach_activity: Optional[LastOutreachActivity] = None
    current_positions: Optional[list[CurrentPosition]] = None
    education: Optional[list[EducationItem1]] = None
    work_experience: Optional[list[WorkExperienceItem1]] = None
    interests: Optional[str] = None


class Items20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["SearchResult"]
    type: Literal["COMPANY"]
    id: str
    name: str
    location: Union[str, Any]
    profile_url: str
    industry: str
    summary: Union[str, Any]
    followers_count: Optional[float] = None
    job_offers_count: Optional[float] = None
    headcount: Optional[str] = None


class Author4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    public_identifier: str
    name: str
    is_company: bool


class RepostContent1(BaseModel):
    """
    The post shared in the current publication.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    date: str
    parsed_datetime: str
    author: Author4
    text: str


class Attachments55(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments56(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments57(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments58(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments59(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Poll1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    total_votes_count: float
    question: str
    is_open: bool
    options: list[Option]


class Items21(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["SearchResult"]
    type: Literal["POST"]
    provider: Literal["LINKEDIN"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    social_id: str = Field(
        ...,
        description="A unique identifier to be used to add a comment or a reaction to the post.",
    )
    share_url: str
    title: Optional[str] = None
    text: str
    date: str
    parsed_datetime: str
    reaction_counter: float
    comment_counter: float
    repost_counter: float
    impressions_counter: float
    author: Author4
    permissions: Permissions
    is_repost: bool
    repost_id: Optional[str] = Field(default=None, description="The republication ID.")
    reposted_by: Optional[RepostedBy] = None
    repost_content: Optional[RepostContent1] = Field(
        default=None, description="The post shared in the current publication."
    )
    attachments: list[
        Union[Attachments55, Attachments56, Attachments57, Attachments58, Attachments59]
    ]
    poll: Optional[Poll1] = None


class PostedAt(RootModel[Any]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: Any = Field(
        ...,
        description="An ISO 8601 UTC datetime (YYYY-MM-DDTHH:MM:SS.sssZ). ⚠️ All links expire upon daily restart, regardless of their stated expiration date. A new link must be generated each time a user clicks on your app to connect.",
        examples=["2025-12-31T23:59:59.999Z"],
        pattern="^[1-2]\\d{3}-[0-1]\\d-[0-3]\\dT\\d{2}:\\d{2}:\\d{2}.\\d{3}Z$",
    )


class Company3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Union[str, Any]
    public_identifier: Union[str, Any]
    name: Union[str, Any]
    profile_url: Union[str, Any]
    profile_picture_url: Union[str, Any]


class Items22(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["SearchResult"]
    type: Literal["JOB"]
    id: str
    reference_id: str
    title: str
    location: Union[str, Any]
    posted_at: Union[PostedAt, Any]
    reposted: bool
    url: str
    company: Union[Company3, Any]


class Min11(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max11(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class HeadcountItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min11] = None
    max: Optional[Max11] = None


class Params1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["companies"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    location: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : LOCATIONS.",
        min_length=1,
        pattern="^\\d+$",
    )
    has_job_offers: Optional[bool] = Field(
        default=None, description="Linkedin native filter : JOB LISTINGS ON LINKEDIN."
    )
    headcount: Optional[list[HeadcountItem2]] = Field(
        default=None, description="Linkedin native filter : COMPANY SIZE."
    )
    network_distance: Optional[list[NetworkDistanceEnum]] = Field(
        default=None,
        description="First, second or third+ degree.\nLinkedin native filter : CONNECTIONS.",
    )


class PostedBy1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    member: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : FROM MEMBER.",
        min_length=1,
        pattern="^.+$",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : FROM COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    me: Optional[bool] = Field(
        default=None, description="Linkedin native filter : POSTED BY [ME]."
    )
    first_connections: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : POSTED BY [1ST CONNECTIONS].",
    )
    people_you_follow: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : POSTED BY [PEOPLE YOU FOLLOW].",
    )


class Mentioning1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    member: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : MENTIONING MEMBER.",
        min_length=1,
        pattern="^.+$",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : MENTIONING COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )


class Author6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : AUTHOR INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : AUTHOR COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : AUTHOR KEYWORDS."
    )


class Params2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["posts"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    sort_by: Optional[SortBy] = Field(
        default=None,
        description="Default value is relevance.\nLinkedin native filter : SORT BY.",
    )
    date_posted: Optional[DatePosted] = Field(
        default=None, description="Linkedin native filter : DATE POSTED."
    )
    content_type: Optional[ContentType] = Field(
        default=None, description="Linkedin native filter : CONTENT TYPE."
    )
    posted_by: Optional[PostedBy1] = None
    mentioning: Optional[Mentioning1] = None
    author: Optional[Author6] = None


class Params3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["classic"]
    category: Literal["jobs"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    sort_by: Optional[SortBy] = Field(
        default=None,
        description="Default value is relevance.\nLinkedin native filter : SORT BY.",
    )
    date_posted: Optional[float] = Field(
        default=None,
        description="The timespan in days since today for the filter to be applied.\nLinkedin native filter : DATE POSTED.",
    )
    region: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : GLOBAL LOCATION.",
        pattern="^\\d+$",
    )
    location: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.\nLinkedin native filter : LOCATION.",
        min_length=1,
        pattern="^\\d+$",
    )
    location_within_area: Optional[float] = Field(
        default=None,
        description="The search zone around the location in miles.\nLinkedin native filter : DISTANCE.",
    )
    industry: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.\nLinkedin native filter : INDUSTRY.",
        min_length=1,
        pattern="^\\d+$",
    )
    seniority: Optional[list[SeniorityEnum]] = Field(
        default=None, description="Linkedin native filter : EXPERIENCE LEVEL."
    )
    function: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_FUNCTION on the List search parameters route to find out the right ID.\nLinkedin native filter : JOB FUNCTION.",
        min_length=1,
        pattern="^[a-z]+$",
    )
    role: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.\nLinkedin native filter : TITLE.",
        min_length=1,
        pattern="^\\d+$",
    )
    job_type: Optional[list[JobTypeEnum]] = Field(
        default=None, description="Linkedin native filter : JOB TYPE."
    )
    company: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.\nLinkedin native filter : COMPANY.",
        min_length=1,
        pattern="^\\d+$",
    )
    presence: Optional[list[PresenceEnum]] = None
    easy_apply: Optional[bool] = Field(
        default=None, description="Linkedin native filter : EASY APPLY."
    )
    has_verifications: Optional[bool] = Field(
        default=None, description="Linkedin native filter : HAS VERIFICATIONS."
    )
    under_10_applicants: Optional[bool] = Field(
        default=None, description="Linkedin native filter : UNDER 10 APPLICANTS."
    )
    in_your_network: Optional[bool] = Field(
        default=None, description="Linkedin native filter : IN YOUR NETWORK."
    )
    fair_chance_employer: Optional[bool] = Field(
        default=None, description="Linkedin native filter : FAIR CHANCE EMPLOYER."
    )
    benefits: Optional[list[Benefit]] = Field(
        default=None, description="Linkedin native filter : BENEFITS."
    )
    commitments: Optional[list[Commitment]] = Field(
        default=None, description="Linkedin native filter : COMMITMENTS."
    )


class Location4(BaseModel):
    """
    Linkedin native filter : GEOGRAPHY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Industry3(BaseModel):
    """
    Linkedin native filter : INDUSTRY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min12(float, Enum):
    NUMBER_0 = 0
    NUMBER_1 = 1
    NUMBER_3 = 3
    NUMBER_6 = 6
    NUMBER_10 = 10


class Max12(float, Enum):
    NUMBER_1 = 1
    NUMBER_2 = 2
    NUMBER_5 = 5
    NUMBER_10 = 10


class TenureItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min12] = None
    max: Optional[Max12] = None


class School1(BaseModel):
    """
    Linkedin native filter : SCHOOL.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Company4(BaseModel):
    """
    Linkedin native filter : CURRENT COMPANY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min13(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max13(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class CompanyHeadcountItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min13] = None
    max: Optional[Max13] = None


class CompanyLocation1(BaseModel):
    """
    Linkedin native filter : COMPANY HEADQUARTERS LOCATION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min14(float, Enum):
    NUMBER_0 = 0
    NUMBER_1 = 1
    NUMBER_3 = 3
    NUMBER_6 = 6
    NUMBER_10 = 10


class Max14(float, Enum):
    NUMBER_1 = 1
    NUMBER_2 = 2
    NUMBER_5 = 5
    NUMBER_10 = 10


class TenureAtCompanyItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min14] = None
    max: Optional[Max14] = None


class PastCompany1(BaseModel):
    """
    Linkedin native filter : PAST COMPANY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Function1(BaseModel):
    """
    Linkedin native filter : FUNCTION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Role3(BaseModel):
    """
    Linkedin native filter : CURRENT JOB TITLE.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class TenureAtRoleItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min14] = None
    max: Optional[Max14] = None


class IncludeEnum2(str, Enum):
    OWNER_PARTNER = "owner/partner"
    CXO = "cxo"
    VICE_PRESIDENT = "vice_president"
    DIRECTOR = "director"
    EXPERIENCED_MANAGER = "experienced_manager"
    ENTRY_LEVEL_MANAGER = "entry_level_manager"
    STRATEGIC = "strategic"
    SENIOR = "senior"
    ENTRY_LEVEL = "entry_level"
    IN_TRAINING = "in_training"


class ExcludeEnum2(str, Enum):
    OWNER_PARTNER = "owner/partner"
    CXO = "cxo"
    VICE_PRESIDENT = "vice_president"
    DIRECTOR = "director"
    EXPERIENCED_MANAGER = "experienced_manager"
    ENTRY_LEVEL_MANAGER = "entry_level_manager"
    STRATEGIC = "strategic"
    SENIOR = "senior"
    ENTRY_LEVEL = "entry_level"
    IN_TRAINING = "in_training"


class Seniority5(BaseModel):
    """
    Linkedin native filter : SENIORITY LEVEL.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[IncludeEnum2]] = None
    exclude: Optional[list[ExcludeEnum2]] = None


class PastRole1(BaseModel):
    """
    Linkedin native filter : PAST JOB TITLE.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class AccountLists2(BaseModel):
    """
    Linkedin native filter : ACCOUNT LISTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )


class LeadLists1(BaseModel):
    """
    Linkedin native filter : LEAD LISTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LEAD_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LEAD_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Params4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["sales_navigator"]
    category: Literal["people"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    saved_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    recent_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type RECENT_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    location: Optional[Location4] = Field(
        default=None, description="Linkedin native filter : GEOGRAPHY."
    )
    industry: Optional[Industry3] = Field(
        default=None, description="Linkedin native filter : INDUSTRY."
    )
    first_name: Optional[str] = Field(
        default=None, description="Linkedin native filter : FIRST NAME."
    )
    last_name: Optional[str] = Field(
        default=None, description="Linkedin native filter : LAST NAME."
    )
    tenure: Optional[list[TenureItem1]] = Field(
        default=None, description="Linkedin native filter : YEARS OF EXPERIENCE."
    )
    groups: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type GROUPS on the List search parameters route to find out the right ID.\nLinkedin native filter : GROUPS.",
        min_length=1,
        pattern="^\\d+$",
    )
    school: Optional[School1] = Field(
        default=None, description="Linkedin native filter : SCHOOL."
    )
    profile_language: Optional[list[str]] = Field(
        default=None,
        description="ISO 639-1 language code.\nLinkedin native filter : PROFILE LANGUAGE.",
        max_length=2,
        min_length=2,
    )
    company: Optional[Company4] = Field(
        default=None, description="Linkedin native filter : CURRENT COMPANY."
    )
    company_headcount: Optional[list[CompanyHeadcountItem2]] = Field(
        default=None, description="Linkedin native filter : COMPANY HEADCOUNT."
    )
    company_type: Optional[list[CompanyTypeEnum]] = Field(
        default=None, description="Linkedin native filter : COMPANY TYPE."
    )
    company_location: Optional[CompanyLocation1] = Field(
        default=None,
        description="Linkedin native filter : COMPANY HEADQUARTERS LOCATION.",
    )
    tenure_at_company: Optional[list[TenureAtCompanyItem1]] = Field(
        default=None, description="Linkedin native filter : YEARS IN CURRENT COMPANY."
    )
    past_company: Optional[PastCompany1] = Field(
        default=None, description="Linkedin native filter : PAST COMPANY."
    )
    function: Optional[Function1] = Field(
        default=None, description="Linkedin native filter : FUNCTION."
    )
    role: Optional[Role3] = Field(
        default=None, description="Linkedin native filter : CURRENT JOB TITLE."
    )
    tenure_at_role: Optional[list[TenureAtRoleItem1]] = Field(
        default=None, description="Linkedin native filter : YEARS IN CURRENT POSITION."
    )
    seniority: Optional[Seniority5] = Field(
        default=None, description="Linkedin native filter : SENIORITY LEVEL."
    )
    past_role: Optional[PastRole1] = Field(
        default=None, description="Linkedin native filter : PAST JOB TITLE."
    )
    following_your_company: Optional[bool] = Field(
        default=None, description="Linkedin native filter : FOLLOWING YOUR COMPANY."
    )
    viewed_your_profile_recently: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : VIEWED YOUR PROFILE RECENTLY.",
    )
    network_distance: Optional[list[Union[NetworkDistance, Literal["GROUP"]]]] = Field(
        default=None,
        description="First, second, third+ degree or GROUP.\nLinkedin native filter : CONNECTION.",
    )
    connections_of: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PEOPLE on the List search parameters route to find out the right ID.\nLinkedin native filter : CONNECTIONS OF.",
        min_length=1,
        pattern="^.+$",
    )
    past_colleague: Optional[bool] = Field(
        default=None, description="Linkedin native filter : PAST COLLEAGUE."
    )
    shared_experiences: Optional[bool] = Field(
        default=None, description="Linkedin native filter : SHARED EXPERIENCES."
    )
    changed_jobs: Optional[bool] = Field(
        default=None, description="Linkedin native filter : CHANGED JOBS."
    )
    posted_on_linkedin: Optional[bool] = Field(
        default=None, description="Linkedin native filter : POSTED ON LINKEDIN."
    )
    mentionned_in_news: Optional[bool] = Field(
        default=None, description="Linkedin native filter : MENTIONNED IN NEWS."
    )
    persona: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type PERSONA on the List search parameters route to find out the right ID.\nLinkedin native filter : PERSONA.",
        min_length=1,
        pattern="^\\d+$",
    )
    account_lists: Optional[AccountLists2] = Field(
        default=None, description="Linkedin native filter : ACCOUNT LISTS."
    )
    lead_lists: Optional[LeadLists1] = Field(
        default=None, description="Linkedin native filter : LEAD LISTS."
    )
    viewed_profile_recently: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : PEOPLE YOU INTERACTED WITH / VIEWED PROFILE.",
    )
    messaged_recently: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : PEOPLE YOU INTERACTED WITH / MESSAGED.",
    )
    include_saved_leads: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : SAVED LEADS AND ACCOUNTS / ALL MY SAVED LEADS.",
    )
    include_saved_accounts: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : SAVED LEADS AND ACCOUNTS / ALL MY SAVED ACCOUNTS.",
    )


class Industry4(BaseModel):
    """
    Linkedin native filter : INDUSTRY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Location5(BaseModel):
    """
    Linkedin native filter : HEADQUARTERS LOCATION.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Min16(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max16(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class HeadcountItem3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min16] = None
    max: Optional[Max16] = None


class DepartmentHeadcount1(BaseModel):
    """
    Linkedin native filter : DEPARTMENT HEADCOUNT.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    department: list[str] = Field(
        ...,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    min: float
    max: float


class DepartmentHeadcountGrowth1(BaseModel):
    """
    Linkedin native filter : DEPARTMENT HEADCOUNT GROWTH.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    department: list[str] = Field(
        ...,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    min: float
    max: float


class Min17(float, Enum):
    NUMBER_0 = 0
    NUMBER_0_2 = 0.2
    NUMBER_1 = 1
    NUMBER_2_5 = 2.5
    NUMBER_5 = 5
    NUMBER_10 = 10
    NUMBER_20 = 20
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_1001 = 1001


class Max17(float, Enum):
    NUMBER_0 = 0
    NUMBER_0_2 = 0.2
    NUMBER_1 = 1
    NUMBER_2_5 = 2.5
    NUMBER_5 = 5
    NUMBER_10 = 10
    NUMBER_20 = 20
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_1001 = 1001


class AnnualRevenue1(BaseModel):
    """
    Linkedin native filter : ANNUAL REVENUE. If you want to use the '1000+' value, please set the 'max' value field to 1001.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    currency: str = Field(
        ..., description="ISO 4217 currency code.", max_length=3, min_length=3
    )
    min: Min17
    max: Max17


class Min18(float, Enum):
    NUMBER_1 = 1
    NUMBER_51 = 51
    NUMBER_101 = 101
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001


class Max18(float, Enum):
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000


class FollowersCountItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min18] = None
    max: Optional[Max18] = None


class Min19(float, Enum):
    NUMBER_0 = 0
    NUMBER_51 = 51
    NUMBER_101 = 101
    NUMBER_251 = 251


class Max19(float, Enum):
    NUMBER_50 = 50
    NUMBER_100 = 100
    NUMBER_250 = 250
    NUMBER_500 = 500


class FortuneItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min19] = None
    max: Optional[Max19] = None


class AccountLists3(BaseModel):
    """
    Linkedin native filter : ACCOUNT LISTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type ACCOUNT_LISTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^(\\d+|ALL)$",
    )


class Params5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["sales_navigator"]
    category: Literal["companies"]
    keywords: Optional[str] = Field(
        default=None, description="Linkedin native filter : KEYWORDS."
    )
    saved_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    recent_search_id: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type RECENT_SEARCHES on the List search parameters route to find out the right ID.\nOverrides all other parameters.",
        pattern="^\\d+$",
    )
    industry: Optional[Industry4] = Field(
        default=None, description="Linkedin native filter : INDUSTRY."
    )
    location: Optional[Location5] = Field(
        default=None, description="Linkedin native filter : HEADQUARTERS LOCATION."
    )
    has_job_offers: Optional[bool] = Field(
        default=None,
        description="Linkedin native filter : JOB OPPORTUNITIES / HIRING ON LINKEDIN.",
    )
    headcount: Optional[list[HeadcountItem3]] = Field(
        default=None, description="Linkedin native filter : COMPANY HEADCOUNT."
    )
    headcount_growth: Optional[HeadcountGrowth] = Field(
        default=None, description="Linkedin native filter : COMPANY HEADCOUNT GROWTH."
    )
    department_headcount: Optional[DepartmentHeadcount1] = Field(
        default=None, description="Linkedin native filter : DEPARTMENT HEADCOUNT."
    )
    department_headcount_growth: Optional[DepartmentHeadcountGrowth1] = Field(
        default=None,
        description="Linkedin native filter : DEPARTMENT HEADCOUNT GROWTH.",
    )
    network_distance: Optional[list[NetworkDistanceEnum]] = Field(
        default=None,
        description="First, second or third+ degree.\nLinkedin native filter : CONNECTION.",
    )
    annual_revenue: Optional[AnnualRevenue1] = Field(
        default=None,
        description="Linkedin native filter : ANNUAL REVENUE. If you want to use the '1000+' value, please set the 'max' value field to 1001.",
    )
    followers_count: Optional[list[FollowersCountItem1]] = Field(
        default=None, description="Linkedin native filter : NUMBER OF FOLLOWERS."
    )
    fortune: Optional[list[FortuneItem1]] = Field(
        default=None, description="Linkedin native filter : FORTUNE."
    )
    technologies: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type TECHNOLOGIES on the List search parameters route to find out the right ID.\nLinkedin native filter : TECHNOLOGIES USED.",
        min_length=1,
        pattern="^\\d+$",
    )
    recent_activities: Optional[list[RecentActivity]] = Field(
        default=None, description="Linkedin native filter : RECENT ACTIVITIES."
    )
    saved_accounts: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_ACCOUNTS on the List search parameters route to find out the right ID.\nLinkedin native filter : SAVED ACCOUNTS.",
        min_length=1,
        pattern="^.+$",
    )
    account_lists: Optional[AccountLists3] = Field(
        default=None, description="Linkedin native filter : ACCOUNT LISTS."
    )


class Scope5(str, Enum):
    CURRENT = "CURRENT"
    OPEN_TO_RELOCATE_ONLY = "OPEN_TO_RELOCATE_ONLY"
    CURRENT_OR_OPEN_TO_RELOCATE = "CURRENT_OR_OPEN_TO_RELOCATE"


class LocationItem7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type LOCATION on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope5] = None
    title: Optional[str] = Field(
        default=None,
        description="The title that came along with the ID in the List search parameters route response. Only necessary if the CURRENT_OR_OPEN_TO_RELOCATE value of the scope parameter is used.",
    )


class Industry5(BaseModel):
    """
    Linkedin native filter : INDUSTRIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type INDUSTRY on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class Scope6(str, Enum):
    CURRENT_OR_PAST = "CURRENT_OR_PAST"
    CURRENT = "CURRENT"
    PAST = "PAST"
    PAST_NOT_CURRENT = "PAST_NOT_CURRENT"
    OPEN_TO_WORK = "OPEN_TO_WORK"


class Role4(BaseModel):
    """
    Linkedin native filter : JOB TITLES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type JOB_TITLE on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    is_selection: bool = Field(
        ...,
        description="Linkedin job titles are either strict filters (only the people with that job) or selections (can include people with related jobs). A strict parameter cannot be used as a selection and vice versa. This information is provided on the List search parameters route results.",
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope6] = None


class Role5(BaseModel):
    """
    Linkedin native filter : JOB TITLES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    keywords: str = Field(
        ...,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope6] = None


class Skills2(BaseModel):
    """
    Linkedin native filter : SKILLS AND ASSESSMENTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type SKILL on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class Skills3(BaseModel):
    """
    Linkedin native filter : SKILLS AND ASSESSMENTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    keywords: str = Field(
        ...,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    priority: Optional[Priority] = None


class Scope8(str, Enum):
    CURRENT_OR_PAST = "CURRENT_OR_PAST"
    CURRENT = "CURRENT"
    PAST = "PAST"
    PAST_NOT_CURRENT = "PAST_NOT_CURRENT"


class Company5(BaseModel):
    """
    Linkedin native filter : COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope8] = None


class Company6(BaseModel):
    """
    Linkedin native filter : COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    keywords: str = Field(
        ...,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    priority: Optional[Priority] = None
    scope: Optional[Scope8] = None


class Min20(float, Enum):
    NUMBER_1 = 1
    NUMBER_11 = 11
    NUMBER_51 = 51
    NUMBER_201 = 201
    NUMBER_501 = 501
    NUMBER_1001 = 1001
    NUMBER_5001 = 5001
    NUMBER_10001 = 10001


class Max20(float, Enum):
    NUMBER_10 = 10
    NUMBER_50 = 50
    NUMBER_200 = 200
    NUMBER_500 = 500
    NUMBER_1000 = 1000
    NUMBER_5000 = 5000
    NUMBER_10000 = 10000


class CompanyHeadcountItem3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min20] = None
    max: Optional[Max20] = None


class CurrentCompanyItem1(BaseModel):
    """
    Linkedin native filter : CURRENT COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class PastCompanyItem3(BaseModel):
    """
    Linkedin native filter : PAST COMPANIES.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type COMPANY on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class SchoolItem3(BaseModel):
    """
    Linkedin native filter : SCHOOLS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ...,
        description="The ID of the parameter. Use type SCHOOL on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    priority: Optional[Priority] = None


class IncludeEnum3(str, Enum):
    OWNER = "owner"
    PARTNER = "partner"
    CXO = "cxo"
    VP = "vp"
    DIRECTOR = "director"
    MANAGER = "manager"
    SENIOR = "senior"
    ENTRY = "entry"
    TRAINING = "training"
    UNPAID = "unpaid"


class ExcludeEnum3(str, Enum):
    OWNER = "owner"
    PARTNER = "partner"
    CXO = "cxo"
    VP = "vp"
    DIRECTOR = "director"
    MANAGER = "manager"
    SENIOR = "senior"
    ENTRY = "entry"
    TRAINING = "training"
    UNPAID = "unpaid"


class Seniority6(BaseModel):
    """
    Linkedin native filter : SENIORITY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[IncludeEnum3]] = None
    exclude: Optional[list[ExcludeEnum3]] = None


class Min21(float, Enum):
    NUMBER_2 = 2
    NUMBER_8 = 8
    NUMBER_15 = 15
    NUMBER_31 = 31


class Max21(float, Enum):
    NUMBER_1 = 1
    NUMBER_7 = 7
    NUMBER_14 = 14
    NUMBER_30 = 30
    NUMBER_90 = 90


class RecentlyJoinedItem1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    min: Optional[Min21] = None
    max: Optional[Max21] = None


class HiringProjects1(BaseModel):
    """
    Linkedin native filter : PROJECTS.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    include: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type HIRING_PROJECTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )
    exclude: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type HIRING_PROJECTS on the List search parameters route to find out the right ID.",
        min_length=1,
        pattern="^\\d+$",
    )


class RecruitingActivityItem1(BaseModel):
    """
    Linkedin native filter : RECRUITING ACTIVITY.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: Id
    priority: Optional[Priority] = None
    timespan: Optional[float] = Field(
        default=None,
        description="The timespan in days since today for the filter to be applied.",
    )


class Params6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    api: Literal["recruiter"]
    category: Literal["people"]
    keywords: Optional[str] = Field(
        default=None,
        description="Boolean modifiers can be used to refine your search.\nExample : developers AND product owners NOT managers",
        min_length=1,
    )
    saved_search: Optional[SavedSearch] = Field(
        default=None, description="This parameter will override all others."
    )
    saved_filter: Optional[str] = Field(
        default=None,
        description="The ID of the parameter. Use type SAVED_FILTERS on the List search parameters route to find out the right ID.",
        pattern="^\\d+$",
    )
    location: Optional[list[LocationItem7]] = None
    location_within_area: Optional[float] = Field(
        default=None, description="The search zone around the location in miles."
    )
    industry: Optional[Industry5] = Field(
        default=None, description="Linkedin native filter : INDUSTRIES."
    )
    role: Optional[list[Union[Role4, Role5]]] = None
    skills: Optional[list[Union[Skills2, Skills3]]] = None
    company: Optional[list[Union[Company5, Company6]]] = None
    company_headcount: Optional[list[CompanyHeadcountItem3]] = Field(
        default=None, description="Linkedin native filter : COMPANY SIZES."
    )
    current_company: Optional[list[CurrentCompanyItem1]] = None
    past_company: Optional[list[PastCompanyItem3]] = None
    school: Optional[list[SchoolItem3]] = None
    groups: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type GROUPS on the List search parameters route to find out the right ID.\nLinkedin native filter : ALL GROUPS.",
        min_length=1,
        pattern="^\\d+$",
    )
    graduation_year: Optional[GraduationYear] = Field(
        default=None,
        description="A range of years.\nLinkedin native filter : YEAR OF GRADUATION.",
    )
    tenure: Optional[Tenure] = Field(
        default=None, description="Linkedin native filter : YEARS OF EXPERIENCE."
    )
    seniority: Optional[Seniority6] = Field(
        default=None, description="Linkedin native filter : SENIORITY."
    )
    function: Optional[list[str]] = Field(
        default=None,
        description="The ID of the parameter. Use type DEPARTMENT on the List search parameters route to find out the right ID.\nLinkedin native filter : JOB FUNCTIONS.",
        min_length=1,
        pattern="^\\d+$",
    )
    network_distance: Optional[list[Union[NetworkDistance, Literal["GROUP"]]]] = Field(
        default=None,
        description="First, second, third+ degree or GROUP.\nLinkedin native filter : NETWORK RELATIONSHIPS.",
    )
    hide_previously_viewed: Optional[HidePreviouslyViewed] = Field(
        default=None, description="Linkedin native filter : HIDE PREVIOUSLY VIEWED."
    )
    profile_language: Optional[list[str]] = Field(
        default=None,
        description="ISO 639-1 language code.\nLinkedin native filter : PROFILE LANGUAGES.",
        max_length=2,
        min_length=2,
    )
    recently_joined: Optional[list[RecentlyJoinedItem1]] = Field(
        default=None, description="Linkedin native filter : RECENTLY JOINED LINKEDIN."
    )
    first_name: Optional[list[str]] = Field(
        default=None, description="Linkedin native filter : FIRST NAMES.", min_length=1
    )
    last_name: Optional[list[str]] = Field(
        default=None, description="Linkedin native filter : LAST NAMES.", min_length=1
    )
    has_military_background: Optional[bool] = Field(
        default=None, description="Linkedin native filter : HAS US MILITARY BACKGROUND."
    )
    past_applicants: Optional[bool] = Field(
        default=None, description="Linkedin native filter : PAST APPLICANTS."
    )
    hiring_projects: Optional[HiringProjects1] = Field(
        default=None, description="Linkedin native filter : PROJECTS."
    )
    recruiting_activity: Optional[list[RecruitingActivityItem1]] = None
    notes: Optional[list[str]] = Field(
        default=None, description="Linkedin native filter : NOTES.", min_length=1
    )


class Params7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    url: str = Field(
        ...,
        description="Linkedin's public search URL. Setting this parameter will override the entire body.",
    )


class Params8(BaseModel):
    """
    In the case of a long cursor, you may want to set it in the body rather than in the query parameters.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    cursor: str = Field(
        ...,
        description="A cursor for pagination purposes. To get the next page of entries, you need to make a new request and fulfill this field with the cursor received in the preceding request. This process should be repeated until all entries have been retrieved.",
        min_length=1,
        title="CursorParam",
    )


class Config(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    params: Optional[
        Union[
            Params,
            Params1,
            Params2,
            Params3,
            Params4,
            Params5,
            Params6,
            Params7,
            Params8,
        ]
    ] = None


class Paging4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start: Union[float, Any]
    page_count: float
    total_count: float


class Cursor(RootModel[str]):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    root: str = Field(
        ...,
        description="A cursor for pagination purposes. To get the next page of entries, you need to make a new request and fulfill this field with the cursor received in the preceding request. This process should be repeated until all entries have been retrieved.",
        min_length=1,
        title="CursorParam",
    )


class ApiV1LinkedinSearchPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinSearch"]
    items: list[Union[Items19, Items20, Items21, Items22]]
    config: Config
    paging: Paging4
    cursor: Union[Cursor, Any]


class Type283(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1LinkedinSearchPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type283
    status: Literal[400]


class Type284(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinSearchPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type284
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type285(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinSearchPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type285
    status: Literal[403]


class Type286(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinSearchPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type286
    status: Literal[404]


class Type287(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinSearchPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type287
    status: Literal[500]


class Type288(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinSearchPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type288
    status: Literal[503]


class ApiV1LinkedinSearchPostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Category(str, Enum):
    ACTIVE = "active"
    DRAFT = "draft"
    CLOSED = "closed"


class Item17(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinJobPosting"]
    id: str
    state: Union[Literal["active"], Literal["draft"], Literal["closed"]]
    title: str
    description: Optional[str] = None
    company: str
    location: str
    applicants_counter: float
    cost: float
    created_at: Optional[float] = None
    published_at: Optional[float] = None
    closed_at: Optional[float] = None


class Paging5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    page_count: float
    total_count: float


class ApiV1LinkedinJobsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinJobPostingList"]
    items: list[Item17]
    cursor: Any
    paging: Paging5


class Type289(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinJobsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type289
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type290(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinJobsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type290
    status: Literal[403]


class Type291(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinJobsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type291
    status: Literal[404]


class Type292(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinJobsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type292
    status: Literal[422]


class Type293(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinJobsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type293
    status: Literal[500]


class Type294(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinJobsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type294
    status: Literal[503]


class ApiV1LinkedinJobsGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1LinkedinJobsIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinJobPosting"]
    id: str
    state: Union[Literal["active"], Literal["draft"], Literal["closed"]]
    title: str
    description: Optional[str] = None
    company: str
    location: str
    applicants_counter: float
    cost: float
    created_at: Optional[float] = None
    published_at: Optional[float] = None
    closed_at: Optional[float] = None


class Type295(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinJobsIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type295
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type296(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinJobsIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type296
    status: Literal[403]


class Type297(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinJobsIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type297
    status: Literal[404]


class Type298(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinJobsIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type298
    status: Literal[422]


class Type299(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinJobsIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type299
    status: Literal[500]


class Type300(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinJobsIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type300
    status: Literal[503]


class ApiV1LinkedinJobsIdGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Start3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    year: float
    month: float


class End3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    year: float
    month: float


class WorkExperienceItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    company: Union[str, Any]
    company_id: Optional[str] = None
    position: Union[str, Any]
    location: Optional[str] = None
    description: Optional[str] = None
    picture_url: Optional[str] = None
    start: Union[Start3, Any]
    end: Union[End3, Any]


class EducationItem2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    school: Union[str, Any]
    school_id: Optional[str] = None
    degree: Optional[str] = None
    description: Optional[str] = None
    field_of_study: Optional[str] = None
    picture_url: Optional[str] = None
    start: Union[Start3, Any]
    end: Union[End3, Any]


class ScreeningQuestion(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    question: str
    answers: list[str]
    success: bool


class Item18(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinJobApplicant"]
    id: str
    profile_id: str
    public_identifier: str
    public_profile_url: str
    name: str
    location: str
    headline: str
    profile_picture_url: Optional[str] = None
    applied_at: float
    email_address: str
    phone_number: str
    work_experience: list[WorkExperienceItem2]
    education: list[EducationItem2]
    screening_questions: list[ScreeningQuestion]


class ApiV1LinkedinJobsIdApplicantsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinJobApplicantList"]
    job_posting_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    items: list[Item18]
    cursor: Any
    paging: Paging5


class Type301(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1LinkedinJobsIdApplicantsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type301
    status: Literal[400]


class Type302(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinJobsIdApplicantsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type302
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type303(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinJobsIdApplicantsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type303
    status: Literal[403]


class Type304(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinJobsIdApplicantsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type304
    status: Literal[404]


class Type305(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinJobsIdApplicantsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type305
    status: Literal[422]


class Type306(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinJobsIdApplicantsGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type306
    status: Literal[500]


class Type307(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinJobsIdApplicantsGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type307
    status: Literal[503]


class ApiV1LinkedinJobsIdApplicantsGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class WorkExperienceItem3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    company: Union[str, Any]
    company_id: Optional[str] = None
    position: Union[str, Any]
    location: Optional[str] = None
    description: Optional[str] = None
    picture_url: Optional[str] = None
    start: Union[Start3, Any]
    end: Union[End3, Any]


class EducationItem3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    school: Union[str, Any]
    school_id: Optional[str] = None
    degree: Optional[str] = None
    description: Optional[str] = None
    field_of_study: Optional[str] = None
    picture_url: Optional[str] = None
    start: Union[Start3, Any]
    end: Union[End3, Any]


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinJobApplicant"]
    id: str
    profile_id: str
    public_identifier: str
    public_profile_url: str
    name: str
    location: str
    headline: str
    profile_picture_url: Optional[str] = None
    applied_at: float
    email_address: str
    phone_number: str
    work_experience: list[WorkExperienceItem3]
    education: list[EducationItem3]
    screening_questions: list[ScreeningQuestion]


class Type308(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type308
    status: Literal[400]


class Type309(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type309
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type310(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type310
    status: Literal[403]


class Type311(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type311
    status: Literal[404]


class Type312(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type312
    status: Literal[422]


class Type313(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type313
    status: Literal[500]


class Type314(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type314
    status: Literal[503]


class ApiV1LinkedinJobsApplicantsApplicantIdGetResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1LinkedinProfileEndorsePostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ..., description="An Unipile account id.", min_length=1, title="AccountIdParam"
    )
    profile_id: str = Field(
        ..., description="The provider ID of the user, starting with ACo."
    )
    skill_endorsement_id: float = Field(
        ...,
        description="This is the endorsement_id that can be found along with the skill details on the result of the Retrieve a profile route : https://developer.unipile.com/reference/userscontroller_getprofilebyidentifier",
    )


class ApiV1LinkedinProfileEndorsePostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["LinkedinProfileEndorse"]
    endorsed: bool


class Type315(str, Enum):
    ERRORS_INVALID_PARAMETERS = "errors/invalid_parameters"
    ERRORS_MALFORMED_REQUEST = "errors/malformed_request"
    ERRORS_CONTENT_TOO_LARGE = "errors/content_too_large"
    ERRORS_INVALID_URL = "errors/invalid_url"
    ERRORS_TOO_MANY_CHARACTERS = "errors/too_many_characters"
    ERRORS_UNESCAPED_CHARACTERS = "errors/unescaped_characters"
    ERRORS_MISSING_PARAMETERS = "errors/missing_parameters"


class ApiV1LinkedinProfileEndorsePostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type315
    status: Literal[400]


class Type316(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1LinkedinProfileEndorsePostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type316
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type317(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1LinkedinProfileEndorsePostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type317
    status: Literal[403]


class Type318(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1LinkedinProfileEndorsePostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type318
    status: Literal[404]


class Type319(str, Enum):
    ERRORS_INVALID_ACCOUNT = "errors/invalid_account"
    ERRORS_INVALID_RECIPIENT = "errors/invalid_recipient"
    ERRORS_NO_CONNECTION_WITH_RECIPIENT = "errors/no_connection_with_recipient"
    ERRORS_BLOCKED_RECIPIENT = "errors/blocked_recipient"
    ERRORS_UNPROCESSABLE_ENTITY = "errors/unprocessable_entity"
    ERRORS_INVALID_MESSAGE = "errors/invalid_message"
    ERRORS_INVALID_POST = "errors/invalid_post"
    ERRORS_NOT_ALLOWED_INMAIL = "errors/not_allowed_inmail"
    ERRORS_INSUFFICIENT_CREDITS = "errors/insufficient_credits"
    ERRORS_CANNOT_RESEND_YET = "errors/cannot_resend_yet"
    ERRORS_LIMIT_EXCEEDED = "errors/limit_exceeded"
    ERRORS_ALREADY_INVITED_RECENTLY = "errors/already_invited_recently"
    ERRORS_CANNOT_INVITE_ATTENDEE = "errors/cannot_invite_attendee"
    ERRORS_PARENT_MAIL_NOT_FOUND = "errors/parent_mail_not_found"
    ERRORS_INVALID_REPLY_SUBJECT = "errors/invalid_reply_subject"
    ERRORS_INVALID_HEADERS = "errors/invalid_headers"
    ERRORS_SEND_AS_DENIED = "errors/send_as_denied"
    ERRORS_INVALID_FOLDER = "errors/invalid_folder"
    ERRORS_LIMIT_TOO_HIGH = "errors/limit_too_high"
    ERRORS_UNAUTHORIZED = "errors/unauthorized"
    ERRORS_SENDER_REJECTED = "errors/sender_rejected"
    ERRORS_RECIPIENT_REJECTED = "errors/recipient_rejected"
    ERRORS_IP_REJECTED_BY_SERVER = "errors/ip_rejected_by_server"
    ERRORS_PROVIDER_UNREACHABLE = "errors/provider_unreachable"
    ERRORS_ACCOUNT_CONFIGURATION_ERROR = "errors/account_configuration_error"


class ApiV1LinkedinProfileEndorsePostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type319
    status: Literal[422]


class Type320(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1LinkedinProfileEndorsePostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type320
    status: Literal[500]


class Type321(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1LinkedinProfileEndorsePostResponse7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type321
    status: Literal[503]


class ApiV1LinkedinProfileEndorsePostResponse8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Author7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    public_identifier: str
    name: str
    is_company: bool


class RepostContent2(BaseModel):
    """
    The post shared in the current publication.
    """

    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    date: str
    parsed_datetime: str
    author: Author7
    text: str


class Attachments60(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["img"]
    size: Size
    sticker: bool


class Attachments61(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["video"]
    size: Size
    gif: bool


class Attachments62(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["audio"]
    duration: Optional[float] = None
    voice_note: bool


class Attachments63(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["file"]
    file_name: str


class Attachments64(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str
    file_size: Optional[float] = None
    unavailable: bool
    mimetype: Optional[str] = None
    url: Optional[str] = None
    url_expires_at: Optional[float] = None
    type: Literal["linkedin_post"]


class Poll2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    total_votes_count: float
    question: str
    is_open: bool
    options: list[Option]


class ApiV1PostsPostIdGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    provider: Literal["LINKEDIN"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    social_id: str = Field(
        ...,
        description="A unique identifier to be used to add a comment or a reaction to the post.",
    )
    share_url: str
    title: Optional[str] = None
    text: str
    date: str
    parsed_datetime: str
    reaction_counter: float
    comment_counter: float
    repost_counter: float
    impressions_counter: float
    author: Author7
    permissions: Permissions
    is_repost: bool
    repost_id: Optional[str] = Field(default=None, description="The republication ID.")
    reposted_by: Optional[RepostedBy] = None
    repost_content: Optional[RepostContent2] = Field(
        default=None, description="The post shared in the current publication."
    )
    attachments: list[
        Union[Attachments60, Attachments61, Attachments62, Attachments63, Attachments64]
    ]
    poll: Optional[Poll2] = None
    object: Literal["Post"]


class Type322(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1PostsPostIdGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type322
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type323(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1PostsPostIdGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type323
    status: Literal[403]


class Type324(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1PostsPostIdGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type324
    status: Literal[500]


class Type325(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1PostsPostIdGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type325
    status: Literal[503]


class ApiV1PostsPostIdGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1PostsPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ...,
        description="The id of the account to perform the request from.",
        min_length=1,
    )
    text: str = Field(..., min_length=1)
    attachments: Optional[list[bytes]] = None


class ApiV1PostsPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["PostCreated"]


class Type326(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1PostsPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type326
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type327(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1PostsPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type327
    status: Literal[403]


class Type328(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1PostsPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type328
    status: Literal[500]


class Type329(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1PostsPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type329
    status: Literal[503]


class ApiV1PostsPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Item19(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["Comment"]
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    post_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    author: Union[str, Any]
    author_details: AuthorDetails
    date: str
    text: str
    reaction_counter: float
    reply_counter: float


class Paging7(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    start: Union[float, Any]
    page_count: float
    total_count: Union[float, Any]


class ApiV1PostsPostIdCommentsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["CommentList"]
    items: list[Item19]
    cursor: Union[str, Any]
    total_items: Union[float, Any]
    paging: Paging7


class Type330(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1PostsPostIdCommentsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type330
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type331(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1PostsPostIdCommentsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type331
    status: Literal[403]


class Type332(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1PostsPostIdCommentsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type332
    status: Literal[500]


class Type333(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1PostsPostIdCommentsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type333
    status: Literal[503]


class ApiV1PostsPostIdCommentsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ApiV1PostsPostIdCommentsPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ...,
        description="The id of the account to perform the request from.",
        min_length=1,
    )
    text: str = Field(..., max_length=1250, min_length=1)
    as_organization: Optional[str] = Field(
        default=None,
        description="Provide the ID of an organization over which you have control to perform the action on its behalf.",
        min_length=1,
    )
    comment_id: Optional[str] = Field(
        default=None, description="The id of the comment to reply to.", min_length=1
    )


class ApiV1PostsPostIdCommentsPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["CommentSent"]


class Type334(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1PostsPostIdCommentsPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type334
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type335(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1PostsPostIdCommentsPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type335
    status: Literal[403]


class Type336(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1PostsPostIdCommentsPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type336
    status: Literal[404]


class Type337(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1PostsPostIdCommentsPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type337
    status: Literal[500]


class Type338(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1PostsPostIdCommentsPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type338
    status: Literal[503]


class ApiV1PostsPostIdCommentsPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class Author9(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    type: Union[Literal["INDIVIDUAL"], Literal["COMPANY"]]
    name: Union[str, Any]
    headline: Union[str, Any]
    profile_url: Union[str, Any]
    network_distance: Optional[
        Union[
            Literal["FIRST_DEGREE"],
            Literal["SECOND_DEGREE"],
            Literal["THIRD_DEGREE"],
            Literal["OUT_OF_NETWORK"],
        ]
    ] = None


class Item20(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["PostReaction"]
    value: Union[
        Literal["LIKE"],
        Literal["PRAISE"],
        Literal["APPRECIATION"],
        Literal["EMPATHY"],
        Literal["INTEREST"],
        Literal["ENTERTAINMENT"],
    ]
    post_id: str = Field(
        ..., description="A unique identifier.", min_length=1, title="UniqueId"
    )
    comment_id: Optional[str] = Field(
        default=None, description="A unique identifier.", min_length=1, title="UniqueId"
    )
    author: Author9


class Paging8(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    cursor: Union[str, Any]
    start: float
    page_count: float
    total_count: float


class ApiV1PostsPostIdReactionsGetResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["PostReactionList"]
    items: list[Item20]
    paging: Paging8


class Type339(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1PostsPostIdReactionsGetResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type339
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type340(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1PostsPostIdReactionsGetResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type340
    status: Literal[403]


class Type341(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1PostsPostIdReactionsGetResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type341
    status: Literal[500]


class Type342(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1PostsPostIdReactionsGetResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type342
    status: Literal[503]


class ApiV1PostsPostIdReactionsGetResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]


class ReactionType(str, Enum):
    LIKE = "like"
    CELEBRATE = "celebrate"
    SUPPORT = "support"
    LOVE = "love"
    INSIGHTFUL = "insightful"
    FUNNY = "funny"


class ApiV1PostsReactionPostRequest(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    account_id: str = Field(
        ...,
        description="The id of the account to perform the request from.",
        min_length=1,
    )
    as_organization: Optional[str] = Field(
        default=None,
        description="Provide the ID of an organization over which you have control to perform the action on its behalf.",
        min_length=1,
    )
    post_id: str = Field(
        ...,
        description="The SOCIAL id of the post to send a reaction to. Please check the Post data schema to get the right id.",
        min_length=1,
    )
    comment_id: Optional[str] = Field(
        default=None,
        description="The id of the comment to send a reaction to.",
        min_length=1,
    )
    reaction_type: Optional[ReactionType] = None


class ApiV1PostsReactionPostResponse(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    object: Literal["ReactionAdded"]


class Type343(str, Enum):
    ERRORS_MISSING_CREDENTIALS = "errors/missing_credentials"
    ERRORS_MULTIPLE_SESSIONS = "errors/multiple_sessions"
    ERRORS_INVALID_CHECKPOINT_SOLUTION = "errors/invalid_checkpoint_solution"
    ERRORS_CHECKPOINT_ERROR = "errors/checkpoint_error"
    ERRORS_INVALID_CREDENTIALS = "errors/invalid_credentials"
    ERRORS_EXPIRED_CREDENTIALS = "errors/expired_credentials"
    ERRORS_INSUFFICIENT_PRIVILEGES = "errors/insufficient_privileges"
    ERRORS_DISCONNECTED_ACCOUNT = "errors/disconnected_account"
    ERRORS_DISCONNECTED_FEATURE = "errors/disconnected_feature"
    ERRORS_INVALID_CREDENTIALS_BUT_VALID_ACCOUNT_IMAP = (
        "errors/invalid_credentials_but_valid_account_imap"
    )
    ERRORS_EXPIRED_LINK = "errors/expired_link"
    ERRORS_WRONG_ACCOUNT = "errors/wrong_account"


class ApiV1PostsReactionPostResponse1(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type343
    status: Literal[401]
    connection_params: Optional[ConnectionParams66] = Field(
        default=None, alias="connectionParams"
    )


class Type344(str, Enum):
    ERRORS_ACCOUNT_RESTRICTED = "errors/account_restricted"
    ERRORS_INSUFFICIENT_PERMISSIONS = "errors/insufficient_permissions"
    ERRORS_SESSION_MISMATCH = "errors/session_mismatch"
    ERRORS_FEATURE_NOT_SUBSCRIBED = "errors/feature_not_subscribed"
    ERRORS_UNKNOWN_AUTHENTICATION_CONTEXT = "errors/unknown_authentication_context"
    ERRORS_RESOURCE_ACCESS_RESTRICTED = "errors/resource_access_restricted"


class ApiV1PostsReactionPostResponse2(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type344
    status: Literal[403]


class Type345(str, Enum):
    ERRORS_RESOURCE_NOT_FOUND = "errors/resource_not_found"
    ERRORS_INVALID_RESOURCE_IDENTIFIER = "errors/invalid_resource_identifier"


class ApiV1PostsReactionPostResponse3(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type345
    status: Literal[404]


class Type346(str, Enum):
    ERRORS_UNEXPECTED_ERROR = "errors/unexpected_error"
    ERRORS_PROVIDER_ERROR = "errors/provider_error"
    ERRORS_AUTHENTICATION_INTENT_ERROR = "errors/authentication_intent_error"


class ApiV1PostsReactionPostResponse4(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type346
    status: Literal[500]


class Type347(str, Enum):
    ERRORS_NO_CLIENT_SESSION = "errors/no_client_session"
    ERRORS_NO_CHANNEL = "errors/no_channel"
    ERRORS_NO_HANDLER = "errors/no_handler"
    ERRORS_NETWORK_DOWN = "errors/network_down"
    ERRORS_SERVICE_UNAVAILABLE = "errors/service_unavailable"


class ApiV1PostsReactionPostResponse5(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Type347
    status: Literal[503]


class ApiV1PostsReactionPostResponse6(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,
    )
    title: str
    detail: Optional[str] = None
    instance: Optional[str] = None
    type: Literal["errors/request_timeout"]
    status: Literal[504]
